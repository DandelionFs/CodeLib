### Preface

记录一些有意思的文章和摘要:



### Preface

C/C++ 的知识, 包含用法.

权威网站推荐
1. https://en.cppreference.com/w/
2. https://www.learncpp.com/
3. http://cplusplus.com/
4. https://github.com/fffaraz/awesome-cpp


### Auto 关键词

> auto不能作为函数的参数
>
> auto不能直接用来声明数组
>
> 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法 ，只是一个占位符
>
> auto不能定义类的非静态成员变量
>
> 实例化模板时不能使用auto作为模板参数

```cpp
int main() {
	int a;
	auto m = a;//C++11后auto 声明的变量必须由编译器在编译时期推导而得
	auto n;//用auto声明引用类型时则必须加&
	auto q = 3.14;//用auto声明指针类型时，用auto和auto*没有任何区别
	auto w = 4;
	auto r = " ";
	auto v = 3, d = 3.0;//求同一类型
}
```

针对于`auto`的使用，在处理复杂类型，如标准模块库（STL）中的类型时，才能显现出来
例如，对于下述C++98代码：——《C++ Primer Plus》

```cpp
std::vector<double> scores；
std::vectorsdouble>::iterator pv = scores.begin();
//C++11允许您将其重写为下面这样:
std::vector<double> scores;
auto pv = scores.begin();
```

对于使用`auto`形成的新的循环:

```cpp
#include<iostream>
using namespace std;
int main() {
	int array[] = { 1,2,3,4,5 };
	for (auto& e : array)e *= 2;
	for (auto& e : array)cout << e << " ";
	cout << endl;
	return 0;
}
```

还是很神奇的，`auto`应该是C++11里面的新特性。



### OVERFLOW 上溢

```cpp
int main(){
	int  sum = 1,i;
	for (i = 1; i <= 32; i++) sum *= 2;
	cout << sum;
}
```

结果是3. 

OVERFLOW为math.h中的一个[宏定义](https://www.baidu.com/s?wd=宏定义&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，其值为3。

含义为运算过程中出现了上溢，即运算结果超出了运算变量所能存储的范围。 



### Data Transform 自动类型转换

```c++
int main() {
	int a;
	cin >> a;
	cout << (5 / 9.0) * (a - 32) << endl; //还是和数字运算的时候不同类型（int double）的 转化相关
	cout << (5 / 9) * (a - 32) << endl;
	cout << 5 / 9 * (a - 32) << endl;
	cout << 5 * (a - 32) / 9 << endl;
}
```

> 编程的过程中需要将值从一种数据类型转换为另一种数据类型 ，C++ 提供了这样做的方法：
>
> 当运算符的操作数具有不同的数据类型时，C++ 会自动将它们转换为相同的数据类型。当它这样做时，遵循一组规则。理解这些规则将有助于程序员防止一些细微的错误蔓延到自己的程序中。就像军队的军官有军阶一样，数据类型也可以按等级排名。如果一个数字数据类型可以容纳的数字大于另一个数据类型，那么它的排名就高于后者。例如，float类型就超越了 int 类型，而 double 类型又超越了 float 类型。

 数字优先级（逐级递减)  ：` long double`、`float``unsigned long long int`    、`long long int`、`unsigned long int`、`long int`、`unsigned int`、`int`。

运行这段代码你会发现结果是`0`,但其实结果是`4,294,967,296`,已经远超int的范围了，所以应该换成`long long`或者`double`才可以。





### Variable

|          数据类型          |                     具体大小                     |
| :------------------------: | :----------------------------------------------: |
|       unsigned   int       |                  0～4294967295                   |
|            int             | <font color="red">-2147483648～2147483647</font> |
|       unsigned long        |                  0～4294967295                   |
|            long            |             -2147483648～2147483647              |
|     long long的最大值      |   <font color="red">9223372036854775807</font>   |
|     long long的最小值      |               -9223372036854775808               |
| unsigned long long的最大值 |               1844674407370955161                |
|      __int64的最大值       |               9223372036854775807                |
|      __int64的最小值       |               -9223372036854775808               |
|  unsigned __int64的最大值  |               18446744073709551615               |

注意：

1. 观察上面的规律： **负数的范围要比正数的范围大1 **、还有一点就是：**数据类型分配的字节数会根据机器的字长和编译器有所不同，不同的大小所表示的范围是不同的。上图唯一一个与机器有关的取值范围是 long 类型的，64位机器使用8个字节（264），而32位机器使用4个字节（232）**
2. C语言的int你会发现有多种不同的版本：有的最大是2^16^,有的最大是2^32^,其实这是**和你的机器和编译器的版本**有关的数据。前者是16位系统的，是最基本的设置，后者是32和64位的版本，**如果你想要最大是2^64^的话，在32位上使用`long long [int]`，在64位上使用`long [int]`**。这是区别。

</br>

#### 定义变量的考量

值得注意的是，在考虑程序的移植性的时候，应该兼顾16位系统的定义：

> 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作，如果要存储的值超过20亿，可使用long long。

</br>

#### 整型字面值

> 整型字面值（常量）是显式地书写的常量，如212或1776，与C相同，C++能够以三种不同的计数方式来书写整数：基数为10、基数为8（老式UNIX版本）和基数为16（硬件黑客的最爱）。
>
> 这里将介绍C++表示法。C++使用前一（两）位来标识数字常量的基数。
>
> 如果第一位为`1~9`，则基数为10（十进制）；因此93是以10为基数的。
>
> 如果第一位是0，第二位为1~7，则基数为8（八进制）；因此`042`的基数是8，它相当于十进制数34。
>
> 如果前两位为Ox或0x，则基数为16（十六进制）；因此0x42为十六进制数，相当于十进制数66，对于十六进制数，字符`a~f`和`A~F`表示了十六进制位，对应于10~15，`OxF`为15，`OxA5`为165（10个16加5个1）。

```cpp
chest = 42; //(42 in decimal)
waist = 66; //(0x42 in hexadecimal )
inseam = 34; //(042 in octal)
```

#### 运算符的结合顺序

这个的重要性不言而喻，简单来说对于`20/4*5`到底是从左往右算，还是从右往左算的结果都是不一样的。因为乘除都是从左到右的，所以最后结果是`25`而不是`1`。运算符重载的`*`(取内容)`+`(取正)`-`(取负)的结合顺序是从右到左，但是相同符号下的加减运算是从左到右，这是容易搞混的点。

### 参数传递

包括形式参数、指针参数、引用参数、指针引用参数。形式参数，顾名思义，只是一个形式，最后不做保留；指针参数，将变量的地址传递到函数中，直接作用于main中的变量；引用参数，和指针略不同。

<font color="red">回去查了一下资料，以下列举：</font>

1.　<font color="red">这里存在一个小的知识点：new返回值是系统给的一片内存的首地址，所以申请内存只可以指针，用引用申请绝对是来捣乱的（手动滑稽）？！</font>
2.　<font color="red">指针数组是可以申请动态内存，但是函数体结束的时候该指针被回收，如果你没有及时把内存地址return回去，内存变成了鬼存（内存泄漏），你也不知道怎么使用。你也是来捣乱的（手动滑稽）</font>

以上，解释完了，另外还有应用的一个小知识，引用底层和指针相似，但是显示的是不占内存，而且在外函数内用完之后，其他函数是无法使用的.(我为什么回文如此脑残的问题？！)

```c++
int lfh(int a, int* b, int& c) {
	int sum = 0, sum1 = 1, sum2 = 0;
	int m = *b, n = c;
	for (int i = 1; i <= a; i++) sum += i;
	for (int i = 1; i <= m; i++) sum2 += i * i;
	for (int i = 1; i <= n; i++) sum1 *= i;
	*b = sum2;
	c = sum1;
	return sum;
}
```

#### 函数返回引用和返回值[·](https://blog.csdn.net/keyouan2008/article/details/5771844)

函数返回**值**时会产生一个临时变量作为函数返回值的副本，而返回**引用**时不会产生值的副本，既然是引用，那引用谁呢？以下是几种引用情况：

1. 引用函数的参数，当然该参数也是一个引用

```c++
const string &shorterString(const string &s1,const string &s2){
return s1.size()<s2.size()?s1:s2;
}
```

以上函数的返回值是引用类型。无论返回s1或是s2,调用函数和返回结果时，都没有复制这些string对象。简单的说，返回的引用是函数的参数s1或s2，同样s1和s2也是引用，而不是在函数体内产生的。

2. 千万不要返回局部对象的引用

```c++
const string &mainip(const string &s){
string ret=s;
return ret;
}
```

当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。











### cin.eof[^2]

in.eof()返回流结束位，如：

```cpp
char gc;
while(!cin.eof()){ //直至按ctrl+z键退出！控制台窗口中，用ctrl+z来模拟文件结束符
  cin>>gc;
  cout<<gc<<endl; 
}
//相应的，在C中使用的是scanf，如
int M, N;
while(scanf("%d%d", &M, &N) != EOF){
      .....
}
```



### 如何操作内存

> 计算机是一种精确的、有条理的机器。要将信息项存储在计算机中，必须指出信息的存储位置和所需的内存空间。在C++中，完成这种任务的一种相对简便的方法，是使用声明语句来指出存储类型并提供位置标签。

### 数组扩容

不存在任何扩容操作，所谓扩容就是申请更大的数组拷贝过去，即所谓的伪扩容。

类似的还有数组的删除操作，思路如下：

![数组删除](http://i.dfslfh.cn/数组删除.png)

### 输出ASKII码 

将char转化int即得。值得注意的是 两位数字不是没有askii码 而是他的码是八位。

值得注意的是，字符数组的初始化为数字 `0`的时候数组内全补充的`\0`（全局变量也可以达到这个效果）,有的时候用动态申请内存的时候，无法保证最后一位的下一位是`\0`来保证数组停下来（判断条件是`p[i]！=‘\0’ `）,所以应该尽量避免这样的判断条件，如果一定要用这个条件，可以选择初始化的时候就全员`\0`.

### `for`&`while`

做题存在的问题——`for`不超`while`超时.

+ 从内存角度考虑:

    + 局部变量在栈内存中存在,当for循环语句结束,那么变量会及时被gc(垃圾回收器)及时的释放掉,不浪费空间
    + 如果使用循环之后还想去访问循环语句中控制那个变量,使用while循环

+ 应用场景 

    + 如果一个需求明确循环的次数,那么使用for循环(开发中使用for循环的几率大于while循环)
    + 如果一个需求,不知道循环了多少次,使用while循环

### 保留小数

```cpp
cout<<setiosflags(ios::fixed)<<setprecision(2);//第一种写法

cout.setf(ios::fixed)；
cout<<setprecision(2);//第二种写法

cout<<fixed<<setprecision(2);//第三种写法
```

其中：

1. `setprecision(n)`：功能是控制浮点数显示的有效数字个数。
    有意思的是：

    ```cpp
    int main() {
    	double p = 12.56;
    	cout << setprecision(1) <<p<< endl;
    }
    ```

    运行结果：`1e+01`.

2. **`showpoint`：显示一个小数点**

3. **`fixed`：**`setprecision(n)`和`fixed`合用的话可以控制小数点后有几位，只要加上以下**任意一个**语句就可以。

    ```cpp
    cout<<setiosflags(ios::fixed);
    cout.setf(ios::fixed);
    cout<fixed;
    ```

### `while(cin>>a)`

**cin>>a的过程是先取得从键盘的输入值a，并将a赋给cin**

如果[输入流](https://www.baidu.com/s?wd=输入流&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)（输入的值有效）正常，就会继续循环获取键盘值，如果[输入流](https://www.baidu.com/s?wd=输入流&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)错误，或者达到文件末尾（在windows下`Ctrl+Z`，在Linux下`Ctrl+D`），该循环就会终止。输入缓冲是行缓冲。当从键盘上输入一串字符并按回车后，这些字符会首先被送到输入缓冲区中存储。每当按下回车键后，cin.get()  就会检测输入缓冲区中是否有了可读的数据。cin.get()  还会对键盘上是否有作为流结束标志的  `Ctrl+Z ` 或者  `Ctrl+D ` 键按下作出检查，其检查的方式有两种：阻塞式以及非阻塞式。(这里有检查而宏定义中没有检查！！!)

 Windows系统中一般采用阻塞式检查 `Ctrl+Z`、Unix/Linux系统下一般采用非阻塞式的检查  Ctrl+D。

 这种阻塞式的方式有一个特点：

1. 只有按下回车之后才有可能检测在此之前是否有`Ctrl+Z`按下。
2. 如果输入缓冲区中有可读的数据则不会检测`Ctrl+Z`（因为有要读的数据，还不能认为到了流的末尾）。
3. Ctrl+Z产生的不是一个普通的ASCII码值，也就是说它产生的不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。明白了这几点之后就可以来解释楼主提出的问题了。

因此，输入流结束的条件就是：`^z ` 之前不能有任何字符输入（回车除外），否则  ^z  起不到流结束的作用。相似地，如果在按 ` Ctrl+D ` 之前已经从键盘输入了字符，则  `Ctrl+D`的作用就相当于回车，即把这些字符送到输入缓冲区供读取使用，此时`Ctrl+D`不再起流结束符的作用。如果按 `Ctrl+D  `之前没有任何键盘输入，则`  Ctrl+D  `就是流结束的信号。

阻塞式检查方式指的是只有在回车键按下之后才对此前是否有  Ctrl+Z  组合键按下进行检查，非阻塞式样指的是按下  Ctrl+D  之后立即响应的方式。例如：

从键盘上输入abcd^z  加  回车之后在Windows系统上是这样处理的：由于回车的作用，前面的  abcd  等字符被送到输入缓冲区（注意：上面说过了，^z不会产生字符，所以更不会存储到输入缓冲区，缓冲区中没有  ^z  的存在）。这时，cin.get()  检测到输入缓冲区中已经有数据存在（因此不再检查是否有  ^z  的输入），于是从缓冲中读取相应的数据。如果都读取完了，则输入缓冲区重新变为空，cin.get()  等待新的输入。可见，尽管有  ^z  按下，但是由于在此之前还有其它输入字符（abcd），所以流也不会结束。

### 主函数的返回类型 

1. `void`,即无返回值
2. ` int`,返回int型

`main`的返回值是返回给系统的,0表示成功,其他为失败。有的时候`int `返回值不写也是可以的如果没有值被返回，系统将得到一个表示程序成功完成的值。来自`main()`的非0值表示出错。

### 宏定义

define的定义更像是简单的文本替换，而不是作为一个量来使用

```cpp
#define Add(a,b) a+b;
```

在一般使用的时候是没有问题的，但是如果遇到如：c * Add(a,b) * d的时候就会出现问题，代数式的本意是a+b然后去和c，d相乘，但是因为使用了define（它只是一个简单的替换），所以式子实际上变成了` c*a + b*d`.

```cpp
#include<iostream>
#define f(x) x*x
using namespace std;
int main(){
	int a = 6.0, b = 2.0;
	cout << double(f(a)) / double(f(b)) << endl;
	cout << sizeof(f(a) / f(b)) << endl;//具体的4去哪里了？？？
}
```

**在大规模的开发过程中，特别是跨平台和系统的软件里，define最重要的功能是条件编译**

```cpp
#ifdef WINDOWS
......
......
#endif
#ifdef LINUX
......
......
#endif
```

可以在编译的时候通过#define设置编译环境

### 截取数字数组的长度

由于字符的长度可以用`strlen`截取，所以我数字字符就看着眼红，自己无聊的时候手写了一个(前提是必须最后一位有`\0`)

```cpp
#define LENGTH(ii) int ii=0;for(ii=0;p[ii]!='\0';ii++);
//用法
LENGTH(step);
cout << step;
```

第二种

```cpp
int Length(int p[]) {
	int step, ii = 0;
	for (ii = 0; p[ii] != '\0'; ii++);
	return ii;
}
```

### exit & return[^3]

1. exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程,而return是返回函数值并退出函数 

2. return是**语言级别**的，它表示了**调用堆栈**的返回；而exit是**系统调用**级别的，它**表示了一个进程的结束**。
    按照ANSI C，在最初调用的main()中使用return和exit()的效果相同。 但要注意这里所说的是“**最初调用**”。**如果main()在一个递归程序中，exit()仍然会终止程序；但return将控制权移交给递归的前一级，直到最初的那一级，此时return才会终止程序**。return和exit()的另一个区别在于，**即使在除main()之外的函数中调用exit()，它也将终止程序。**
3. exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。

4. 和机器和操作系统有关一般是  0 为正常退出 非0 为非正常退出

### C 源程序最后一行要是一个空行？

[Ori] : https://www.zhihu.com/question/20018991/answer/15239139

> C 语言它对文件的处理遵循一个基本的原则: 

> **文件是流式的，可以被任意的拼接并且拼接后仍然保证完整性。**
>
> 为了保证这一点，在 Unix 中 \\n 符号被定义为一行的『结束符』，即如果一行的结尾没有 \\n 视为这一行没有结束，说明这个文件不完整，也就是说这根本不是一个合法的文本文件。同时为了保证这一点，Unix 文本通常不允许使用 BOM，因为 BOM 拼接之后将出现在字符流的中间位置，无法有效的定义其处理方法。在 Windows 中 \\n 定义为两行之间的『分隔符』而非结束符，所以 Unix 文件结尾的 \\n ，在 Windows 看起来就是一个空行，而这一个空行在 Unix 中并不存在，如果你使用 Vim 之类的文本编辑器，会根本看不到最后这个空行。





### Code Way

+ char数组写的时候一定要记住最后的'\0'，因为他的后面可能是随机数，也可能全是0，好点的编译器会给你加\0,但是不要侥幸。
+ dec的用处就是1在其他编译器里去转换。
+ 逻辑结构的背后是逻辑电路，正如逻辑语言背后是逻辑内存
+ 遇到有限制条件的题在进行循环的时候将限制条件放在第一位（如题1128）——逻辑短路
+ 读取EOF的意思：`while(scanf("%d %d%d",&m,&n,&t)!=EOF&&(n&&m&&t)) `
+ 在有些语言中，有返回值的函数被称为函数（function）；没有返回值的函数被称为过程（procedure）或子程序（subroutine），但C++与C一样，这两种变体都被称为函数。
+ 数组初始化的问题，不可以写`int p[N]`但是Devcpp里面却可以，这是因为C语言C99标准里的变长数组VLA,c++标准不支持。gcc编译器支持变长数组,但vc那个编译器不支持。你搜一下变长数组。会有很多这个资料的。
+ 二维数组初始化不可以用（）因为会识别为逗号表达式，返回最后的值。
+ static_cast是一个c++运算符，功能是把一个表达式转换为某种类型，但没有运行时类型检查来保证转换的安全性。



### Error

| Section               | What                                                         |
| --------------------- | ------------------------------------------------------------ |
| Accepted              | 你的程序对所有的测试数据都输出了正确的答案，你已经得到了该题的所有分数，恭喜。 |
| Wrong Answer          | 评判系统测试到你的程序对若干组（或者全部）测试数据没有输出正确的结果。<br />出现该种错误后，一般有两种解决方向：<br />1. 如果对设计的算法正确性有较大的把握，那么你可以**重点考虑代码健壮性**，即是否存在某些特殊数据使程序出现错误，比如边界数据，比如程序中变量出现溢出。<br />2. 即怀疑算法本身的正确性，那么你就需要重新考虑你的算法设计了。 |
| Presentation Error    | 评判系统认为你的程序输出“好像”是正确的，只是没有严格按照题目当中输出所要求的输出格式来输出你的答案，例如你忽略了题目要求在每组输出后再输出一个空行。<br/>出现这种错误，往往预示着你离完全正确已经不远了，出现错误似乎只是因为**多输出了一些空格、换行之类的多余字待而已**。但这**不是绝对**的，假如在排版题中出现格式错误，那么有可能你离正确的答案仍然有一定的距离。 |
| Time Limit Exceeded   | 你的程序在输出所有需要输出的答案之前已经超过了题目中所规定的时间。<br/>若这种结果出现在你的评判结果里，依然有两种方向可供参考：<br />1. 假如你确定算法时间复杂度能够符合题目的要求，那么依旧可以检查是否程序**可能在某种情况下出现死循环**，**是否有边界数据**可能会让你的代码不按照预想的工作，从而使程序不能正常的结束。<br />2.你设计的**算法时间复杂度**是否已经离于题目对复杂度的要求，如果是这样，那么你需要重新设计更加高效的算法或者对你现行的算法进行一定的优化。 |
| Runtime Error         | 你的程序在计算答案的过程中由于出现了某种致命的原因异常终止。你可以考虑以下几个要点来排除该错误：<br />1. 程序是否**访问了不该访问的内存地址**，比如访问**数组下标越界**。<br />2.程序是否出现了**除以整数0**，从而使程序异常。<br />3.程序**是否调用了评判系统禁止调用的函数**。<br />4.程序是否会出现**因为递归过深或其他原因造成的栈溢出**。 |
| Compile Error         | 你提交的程序并没有通过评判系统的编译，可根据更详细的编译信息修改你的程序。 |
| Memory Limit Exceeded | 你提交的程序在运行输出所有的答案之前所调用的内存已经超过了题目中所限定的内存限制。造成这种错误的原因主要有两个方面：<br />1.你的程序**申请过多的内存**来完成所要求的工作，即**算法空间复杂度**过高。<br />2.因为**程序本身的某种错误使得程序不断的申请内存**，例如因为某种原因出现了**死循环，使得队列中不断的被放入元素**。当然也千万别忽略自己的低级错误，比如**在声明数组大小时多打了一个0**。 |
| Output Limit Exceeded | 你的程序**输出了过多的东西，甚至超出了评判系统为了自我保护而设定的被评判程序输出大小的最高上限**。一般来说该种错误并不常见，一旦出现了也 很好找原因。<br />1. 要么就是你在提交时忘记关闭你在调试时输出的调试信息（我经常输出DP时的数组来动态的观察状态的转）<br />2.要么就是程序的输出部分出现了死循环，使得程序不断地输出而超出系统的限制。<br/>3.其实还有一种错误就是你容易把其中的一些字符给打错这样子 |


### `<std/c++lib>`万能头文件

万能头文件在VSCode里面不可以联想检查错误语法, 但是可以编译运行.

```cpp
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
```

                   

## assert()

编写代码时，我们总是会做出一些假设，断言（`assert`）就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。

> 注意assert()是一个宏，而不是函数。

### assert所在的头文件及原型

在`MinGW`工具中，`assert()`宏在存在于头文件`assert.h`中，其关键内容如下：

```c
#ifdef NDEBUG
#define assert(x)    ((void)0)
#else /* debugging enabled */

_CRTIMP void __cdecl __MINGW_NOTHROW _assert (const char*, const char*, int) __MINGW_ATTRIB_NORETURN;

#define assert(e)       ((e) ? (void)0 : _assert(#e, __FILE__, __LINE__))

#endif    /* NDEBUG */
```

assert()宏接受一个整形表达式参数。如果表达式的值为假，assert()宏就会调用`_assert`函数在标准错误流中打印一条错误信息，并调用`abort()`（abort()函数的原型在`stdlib.h`头文件中）函数终止程序。

当我们认为已经排除了程序的bug时，就可以把宏定义`#define NDEBUG`写在包含`assert.h`位置前面。

小知识：

- `__cdecl`是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈。
- `_CRTIMP`是C run time implement的简写，C运行库的实现的意思。作为用户代码，不应该使用这个东西。提示是使用dll的动态 C 运行时库还是静态连接的 C 运行库的一个宏。

```c
#ifndef _CRTIMP
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else /* ndef _DLL */
#define _CRTIMP
#endif /* _DLL */
#endif /* _CRTIMP */
```

- `__MINGW_NOTHROW`与`__MINGW_ATTRIB_NORETURN`是异常处理相关标识

这几个标识符在C语言标准库文件中都有用得到，但是我们不需要关心，在我们用户的角度来看，以上函数原型我们看成：`void _assert(const char*, const char*, int)；`即可。

### assert应用

assert主要用于类型检查及单元测试中。

> 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数。

#### 除法运算

```c
/*
编译环境：mingw32  gcc6.3.0
*/
#include <stdio.h>
#include <assert.h>

int main(void)
{
    int a, b, c;
    printf("请输入b, c的值：");
    scanf("%d %d", &b, &c);
    a = b / c;
    printf("a = %d", a);
    return 0;
}
```

此处，变量c作为分母是不能等于0，如果我们输入`2 0`，结果是什么呢？结果是程序会蹦：

![img](https://s2.ax1x.com/2019/08/13/mpHAo9.png)

这个例子中只有几行代码，我们很快就可以找到程序蹦的原因就是变量c的值为0。但是，如果代码量很大，我们还能这么快的找到问题点吗？

这时候，`assert()`就派上用场了，以上代码中，我们可以在`a = b / c;`这句代码之前加上`assert(c);`这句代码用来判断变量c的有效性。此时，再编译运行，得到的结果为：

![img](https://s2.ax1x.com/2019/08/13/mpHPLF.png)

可见，程序蹦的同时还会在标准错误流中打印一条错误信息：

> Assertion failed：c, file hello.c, line 12

这条信息包含了一些对我们查找bug很有帮助的信息：问题出在变量c，在`hello.c`文件的第12行。这么一来，我们就可以迅速的定位到问题点了。

这时候细心的朋友会发现，上边我们对`assert()的`介绍中，有这么一句说明：**如果表达式的值为假，assert()宏就会调用_assert函数在标准错误流中打印一条错误信息，并调用abort()（abort()函数的原型在stdlib.h头文件中）函数终止程序。**

所以，针对我们这个例子，我们的`assert()宏`我们也可以用以下代码来代替：

```c
if (0 == c)
{
    puts("c的值不能为0，请重新输入！");
    abort();
}
```

这样，也可以给我们起到提示的作用：
![img](https://s2.ax1x.com/2019/08/13/mpHkdJ.png)

但是，使用`assert()`至少有几个好处：

1）能自动标识文件和出问题的行号。

2）无需要更改代码就能开启或关闭assert机制(开不开启关系到程序大小的问题)。如果认为已经排除了程序的bug，就可以把下面的宏定义写在包含`assert.h`的位置的前面：

```c
#define NDEBUG
```

并重新编译程序，这样编辑器就会禁用工程文件中所有的assert()语句。如果程序又出现问题，可以移除这条`#define`指令（或把它注释掉），然后重新编译程序，这样就可以重新启用了`assert()`语句。

#### **STM32库函数**

我们来看我们比较熟悉的GPIO初始化函数：



![img](https://s2.ax1x.com/2019/08/13/mpHFZ4.png)



可见，该函数的实现中，有三条`assert_param()`这样的语句，其作用就是对一些函数入口参数进行一些有效性检查。其实`assert_param()`这就类似与我们C标准库中的`assert()`。针对`stm32f10x`系列来说，其被定义在文件`stm32f10x_conf.h`中：



![img](https://s2.ax1x.com/2019/08/13/mpHCsU.png)



这是一个例子，除了GPIO初始化函数之外，STM32固件库函数中的其他函数都是会做这样的参数检查。

## assert & if

assert()断言功能好像用if也能实现，仔细一看这两者还是有区别。下面看一下它们的区别：

先看一个例子，我们使用`malloc`函数定义一个存着堆空间中的变量，我们该怎么定义及该怎么做一些防御处理呢？

首先，我们要知道，`malloc`函数如果分配成功内存则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针`NULL`。看如下代码：

```c
int* p = (int*)malloc(sizeof(int))；
assert(p);        /* 错误示例 */
```

这么写会有问题吗？

看似没问题，但是问题很大！我们的`assert()`会在我们调试完毕之后禁用掉，这么一来以上代码就相当于只有下面这一句了：

```c
int* p = (int*)malloc(sizeof(int))；
```

此时，当我们的程序在跑的时候malloc申请不到内存空间了，也没有做一些解决措施，可能就会产生致命错误。

我们应该把以上代码改写为：

```c
int* p = (int*)malloc(sizeof(int))；
if (NULL == p) /*请使用if来判断,这是有必要的*/
{
    /* 做一些处理 */
}
```

下面看一下`assert`与`if`做防错处理的几点用法区别：

1、`assert`语句用在`debug版本`的调试中；`if(NULL!=p)`是在`release版本`中检验指针的有效性；

2、assert一般用与检查函数参数的合法性（有效性）而不是正确性，但是合法的程序并不见得是程序逻辑正确的程序，该用if做判断处理的地方还是得做处理。

也就是`assert`在调试期间用来检查一些`不允许出现的情况`是否有发生，一旦发生就表明我们的程序很可能有`BUG`，而`if`判断的就是我们理所应当处理的各种情况，且这些情况如果发生并不代表程序发生BUG。

### _Static_assert(C11标准)

`assert()`是在运行时进行检查的，如果一份工程很大，编译起来需要很长时间，一些情况在运行时检查，效率就比较低了。

这时候`_Static_assert()`就派上用场了，这是C11标准中的一个特性，`_Static_assert()`在编译时进行检查，如果编译时检测到代码里的一些异常情况，就会导致程序无法通过编译。下面来看一个例子：

```c
/*
编译环境：mingw32  gcc6.3.0
编译命令：gcc -std=c11 hello.c -o hello.exe
*/
#include <stdio.h>
#include <limits.h>  /*CHAR_BIT是limits.h中的一个宏*/

_Static_assert(CHAR_BIT == 16, "16-bit char falsely assumed");

int main(void)
{
    printf("欢迎关注嵌入式大杂烩！查看更多笔记\n");
    return 0;
}
```

_Static_assert接受两个参数，第一个参数是整型常量表达式，第二个参数是一个字符串。如果第一个表达式为0，编译时就会输出第二个参数的字符串，而且编译不通过。

## 右值引用[^4]


右值引用的概念有些读者可能会感到陌生，其实他和C++98/03中的左值引用有些类似，例如，c++98/03中的左值引用是这样的：

```
int i = 0;
int& j = i;
```

这里的int&是对左值进行绑定（但是int&却不能绑定右值），相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&&，通过双引号来表示绑定类型为A的右值。通过&&我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：

```
int&& i = 0;
```

这里我们绑定了一个右值0，关于右值的概念会在后面介绍。右值引用是C++11中新增加的一个很重要的特性，他主是要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。

和右值引用相关的概念比较多，比如：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义和完美转发等等。很多都是新概念，对于刚学习C++11右值引用的初学者来说，可能会觉得右值引用过于复杂，概念之间的关系难以理清。

右值引用实际上并没有那么复杂，其实是关于4行代码的故事，通过简单的4行代码我们就能清晰的理解右值引用相关的概念了。本文希望带领读者通过4行代码来理解右值引用相关的概念，理清他们之间的关系，并最终能透彻地掌握C++11的新特性--右值引用。

### 第1行代码的故事

```
int i = getVar();
```

上面的这行代码很简单，从getVar()函数获取一个整形值，然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。

所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：

```
int i = 0;
```

在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。关于将亡值我们会在后面介绍，先看下面的代码：

```
int j = 5;

auto f = []{return 5;};
```

上面的代码中5是一个原始字面量， []{return 5;}是一个lambda表达式，都是属于纯右值，他们的特点是在表达式结束之后就销毁了。

通过地行代码我们对右值有了一个初步的认识，知道了什么是右值，接下来再来看看第二行代码。

### 第2行代码的故事

```
T&& k = getVar();
```

第二行代码和第一行代码很像，只是相比第一行代码多了“&&”，他就是右值引用，我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。

#### 右值引用的第一个特点

通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。如代码清单1-1所示。

代码清单1-1 

按 Ctrl+C 复制代码

按 Ctrl+C 复制代码

为了清楚的观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果。

输出结果：
```
construct: 1
copy construct: 1
destruct: 1
copy construct: 2
destruct: 2
destruct: 3
```
从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是：
```
construct: 1
destruct: 1
```

可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则。我们在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，结果又会是什么样的呢？在编译时设置编译选项-fno-elide-constructors。

```
int main() {
    A&& a = GetA();
    return 0;
}
输出结果：
construct: 1
copy construct: 1
destruct: 1
destruct: 2
```


通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成：`const A& a = GetA()`;

输出的结果和右值引用一样，因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：`A& a = GetA();`

上面的代码会报一个编译错误，因为非常量左值引用只能接受左值。

#### 右值引用的第二个特点

右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。比如下面的例子：

```
int&& var1 = 1; 
```

var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。

关于右值引用一个有意思的问题是：T&&是什么，一定是右值吗？让我们来看看下面的例子：
```
template<typename T>
void f(T&& t){}

f(10); //t是右值

int x = 10;
f(x); //t是左值
```

从上面的代码中可以看到，T&&表示的值类型不确定，可能是左值又可能是右值，这一点看起来有点奇怪，这就是右值引用的一个特点。

#### 右值引用的第三个特点

T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。

我们再回过头看上面的代码，对于函数template<typename T>void f(T&& t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&&才是universal references。再看看下面的例子：

```
template<typename T>
void f(T&& param); 

template<typename T>
class Test {
    Test(Test&& rhs); 
};
```
上面的例子中，param是universal reference，rhs是Test&&右值引用，因为模版函数f发生了类型推断，而Test&&并没有发生类型推导，因为Test&&是确定的类型了。

正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。

这里再提一下引用折叠，正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11确定了引用折叠的规则，规则是这样的：

- 所有的右值引用叠加到右值引用上仍然还是一个右值引用；
- 所有的其他引用类型之间的叠加都将变成左值引用。

### 第3行代码的故事

```
T(T&& a) : m_val(val){ a.m_val=nullptr; }
```

这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子。如代码清单1-2所示。

代码清单1-2
```
class A
{
public:
    A():m_ptr(new int(0)){cout << "construct" << endl;}
    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数
    {
        cout << "copy construct" << endl;
    }
    ~A(){ delete m_ptr;}
private:
    int* m_ptr;
};
int main() {
    A a = GetA();
    return 0;
}
    输出：
construct
copy construct
copy construct
```

这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（编译选项-fno-elide-constructors），内部的m_ptr将会被删除两次，一次是临时右值析构的时候删除一次，第二次外面构造的a对象释放时删除一次，而这两个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的。比如下面的代码：

![img](https://images0.cnblogs.com/blog/468725/201502/101140588706822.png)

上面代码中的GetA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？答案是肯定的，C++11已经有了解决方法，看看下面的代码。如代码清单1-3所示。

代码清单1-3
```
class A
{
public:
    A() :m_ptr(new int(0)){}
    A(const A& a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数
    {
        cout << "copy construct" << endl;
    }
    A(A&& a) :m_ptr(a.m_ptr)
    {
        a.m_ptr = nullptr;
        cout << "move construct" << endl;
    }
    ~A(){ delete m_ptr;}
private:
    int* m_ptr;
};
int main(){
    A a = Get(false); 
} 
输出：
construct
move construct
move construct
```

代码清单1-3和1-2相比只多了一个构造函数，输出结果表明，并没有调用拷贝构造函数，只调用了move construct函数，让我们来看看这个move construct函数：

```
A(A&& a) :m_ptr(a.m_ptr)
{
    a.m_ptr = nullptr;
    cout << "move construct" << endl;
}
```

这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。

上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&&表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&&可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。

需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。

我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。如图1-1所示是深拷贝和move的区别。

![img](https://images0.cnblogs.com/blog/468725/201502/101142355425922.jpg)

图1-1 深拷贝和move的区别

再看看下面的例子：

```
{
    std::list< std::string> tokens;
    //省略初始化...
    std::list< std::string> t = tokens; //这里存在拷贝 
}
std::list< std::string> tokens;
std::list< std::string> t = std::move(tokens);  //这里没有拷贝 
```


如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。

这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。

### 第4行代码故事

```
template <typename T>void f(T&& val){ foo(std::forward<T>(val)); }
```

C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如： 

```
template <typename T>
void forwardValue(T& val)
{
    processValue(val); //右值参数会变成左值 
}
template <typename T>
void forwardValue(const T& val)
{
    processValue(val); //参数都变成常量左值引用了 
}
```
都不能按照参数的本来的类型进行转发。

C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。看下面的例子：

```
void processValue(int& a){ cout << "lvalue" << endl; }
void processValue(int&& a){ cout << "rvalue" << endl; }
template <typename T>
void forwardValue(T&& val)
{
    processValue(std::forward<T>(val)); //照参数本来的类型进行转发。
}
void Testdelcl()
{
    int i = 0;
    forwardValue(i); //传入左值 
    forwardValue(0);//传入右值 
}
输出：
lvaue 
rvalue
```

右值引用T&&是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。

我们可以结合完美转发和移动语义来实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：

```
template<typename…  Args>
T* Instance(Args&&… args)
{
    return new T(std::forward<Args >(args)…);
}
```

这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。

## 总结

通过4行代码我们知道了什么是右值和右值引用，以及右值引用的一些特点，利用这些特点我们才方便实现移动语义和完美转发。C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

**本文曾发表于《程序员》2015年1月刊。转载请注明出处。**

**后记：**本文的内容主要来自于我在公司内部培训的一次课程，因为很多人对C++11右值引用搞不清或者理解得不深入，所以我觉得有必要拿出来分享一下，让更多的人看到，就整理了一下发到程序员杂志了，我相信读者看完之后对右值引用会有全面深入的了解。

## 非常量引用的初始值必须为左值的问题[^5]

首先，先看下面一个例子：
```cpp
#include<iostream>
using namespace std;
int main(){
int i =2;
double &r =i;
return 0;
}
// gcc error: invalid initialization of reference of type 'double&' from expression of type 'int'
```
如果改成 const double &r =i;没有问题。

难道这里的i不是左值？

程序改成 :

```cpp
int main(){
double i =2;
double &r =i;
return 0;
}
```

没有错误

难道这里的i又是左值啦？

其实：`const double &r = i;` 由于类型不匹配，实际相当于：`const double inner_tmp = (double)i;` 这里就产生了一个临时变量`const double &r = inner_tmp;`临时的中间变量都是const，所有没有const的引用会失败。


**左值与右值的区分**

 

**首先理解什么是右值引用**：

>右值引用（及其支持的Move语意和完美转发）是C++0x将要加入的最重大语言特性之一，这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升… 　在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &类型。这样函数便无法区分传给const &的是真实的右值还是常规变量。而且，由于类型为const &，函数也无法改变所传对象的值。C++0x将增加一种名为右值引用的新的引用类型，记作typename &&。这种类型可以被接受为非const值，从而允许改变其值。

**区分左值与右值：**

C++ 11中引入的一个非常重要的概念就是右值引用。理解右值引用是学习“移动语义”（move semantics）的基础。而要理解右值引用，就必须先区分左值与右值。

对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。

左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。下面给出一些例子来进行说明。 

```cpp
int a = 10;
 int b = 20;
 int* pFlag = &a;
 vector<<span style="line-height: 25px; color: rgb(0, 0, 255);">int> vctTemp;
 vctTemp.push_back(1);
 string str1 = "hello ";
 string str2 = "world";
 const int &m = 1;
```

请问，a，b, a+b, a++, ++a, pFlag, *pFlag, vctTemp[0], 100, string("hello"), str1, str1+str2, m分别是左值还是右值？

**什么是左值引用：**
区分清楚了左值与右值，我们再来看看左值引用。左值引用根据其修饰符的不同，可以分为非常量左值引用(**eg.1 double &r =i;**)和常量左值引用(**eg.1 const double &r =i;**)。

非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义(**eg.1中就是出现了非常量左值引用绑定到常量右值的情况**)。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。

常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。

 

**为什么要区分非常量右值引用：**

可以看出，使用左值引用时，我们无法区分出绑定的是否是非常量右值的情况。那么，为什么要对非常量右值进行区分呢，区分出来了又有什么好处呢？这就牵涉到C++中一个著名的性能问题——拷贝临时对象。考虑下面的代码： 
```cpp
vector<<span style="line-height: 25px; color: rgb(0, 0, 255);">int> GetAllScores()
 {
 vector<<span style="line-height: 25px; color: rgb(0, 0, 255);">int> vctTemp;
 vctTemp.push_back(90);
 vctTemp.push_back(95);
 returnvctTemp;
 }
```
当使用vector vctScore = GetAllScores()进行初始化时，实际上调用了三次构造函数。尽管有些编译器可以采用RVO（Return Value Optimization）来进行优化，但优化工作只在某些特定条件下才能进行。可以看到，上面很普通的一个函数调用，由于存在临时对象的拷贝，导致了额外的两次拷贝构造函数和析构函数的开销。当然，我们也可以修改函数的形式为void GetAllScores(vector &vctScore)，但这并不一定就是我们需要的形式。另外，考虑下面字符串的连接操作：

```cpp
strings1("hello");
strings = s1 + "a"+ "b"+ "c"+ "d"+ "e";
```

在对s进行初始化时，会产生大量的临时对象，并涉及到大量字符串的拷贝操作，这显然会影响程序的效率和性能。怎么解决这个问题呢？如果我们能确定某个值是一个非常量右值（或者是一个以后不会再使用的左值），则我们在进行临时对象的拷贝时，可以不用拷贝实际的数据，而只是“窃取”指向实际数据的指针（类似于STL中的auto_ptr，会转移所有权）。C++ 11中引入的右值引用正好可用于标识一个非常量右值。C++ 11中用&表示左值引用，用&&表示右值引用，如：`int&&a = 10; `右值引用根据其修饰符的不同，也可以分为非常量右值引用和常量右值引用。

非常量右值引用只能绑定到非常量右值，不能绑定到非常量左值、常量左值和常量右值（VS2010 beta版中可以绑定到非常量左值和常量左值，但正式版中为了安全起见，已不允许）。如果允许绑定到非常量左值，则可能会错误地窃取一个持久对象的数据，而这是非常危险的；如果允许绑定到常量左值和常量右值，则非常量右值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义。

常量右值引用可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值（理由同上）。可以看出，使用左值引用时，我们无法区分出绑定的是否是非常量。


## C++有没有类C中的sprintf和sscanf函数似？

```cpp
#inlucde <sstream>
stringstream ss;
ss <<a <<b <<"=" <<d <<ends;
cout <<ss.str() <<endl;


#include "iostream"
#include "string"
#include "sstream"
using namespace std;

void main()
{
  string a("12+");
  string b("12");
  int d=24;
  string c;

  //add by meteor007
  string e;
  ostringstream ost(e);
  ost<<d;

  c=a+b+"="+ost.str();
  
  cout<<c<<endl;
}
```
## 共用体Union&Struct

构造数据类型,也叫联合体用途：使几个不同类型的变量共占一段内存(相互覆盖)

结构体是一种构造数据类型用途：把不同类型的数据组合成一个整体; 

自定义数据结构体变量所占内存长度是各成员占的内存长度的总和。共同体变量所占内存长度是各最长的成员占的内存长度。

共同体每次只能存放哪个的一种！！共同体变量中起作用的成员是尊后一次存放的成员，在存入新的成员后原有的成员失去了作用！Structure 与 Union主要有以下区别:

1. struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。
2. 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。


## C语言中void*详解及应用[^6]

void在英文中作为名词的解释为“空虚；空间；空隙”；而在C语言中，void被翻译为“无类型”，相应的void *为“无类型指针”。void似乎只有“注释”和限制程序的作用，当然，这里的“注释”不是为我们人提供注释，而是为编译器提供一种所谓的注释。

作用：
1. 对函数返回的限定，这种情况我们比较常见。
2. 对函数参数的限定，这种情况也是比较常见的。

一般我们常见的就是这两种情况：

1. 当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。
2. 当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。

### void指针的使用规则：

1. void指针可以指向任意类型的数据，就是说可以用任意类型的指针对void指针对void指针赋值。例如：

```cpp
int *a；
void *p；
p=a；
```

如果要将void指针p赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到void指针使用：内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据（int *)malloc(1024)表示强制规定malloc返回的void*指针指向的内存中存放的是一个个的int型数据。

2. 在ANSI C标准中，不允许对void指针进行一些算术运算如p++或p+=1等，因为既然void是无类型，那么每次算术运算我们就不知道该操作几个字节，例如char型操作sizeof（char）字节，而int则要操作sizeof（int）字节。而在GNU中则允许，因为在缺省情况下，GNU 认为void *和char *一样，既然是确定的，当然可以进行一些算术操作，在这里sizeof（*p）==sizeof（char）。void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，让我们试着来定义：

    `void a;`

    这行语句编译时会出错，提示“illegal use of type 'void'”。即使void a的编译不会出错，它也没有任何实际意义。众所周知，如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。

```
 float *p1;
 int *p2;
 p1 = p2;
 //其中p1 = p2语句会编译出错，
 //提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：
 p1 = (float *)p2;
```

 而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换

```
void *p1;
int *p2;
p1 = p2;
```

但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。

小心使用void指针类型:

按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：

```
void * pvoid;
pvoid++; //ANSI：错误
pvoid += 1; //ANSI：错误
//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。
//例如：
int *pint;
pint++; //ANSI：正确
pint++的结果是使其增大sizeof(int)。
```

但是GNU则不这么认定，它指定void *的算法操作与char *一致。因此下列语句在GNU编译器中皆正确： 

```
pvoid++; //GNU：正确
pvoid += 1; //GNU：正确
pvoid++的执行结果是其增大了1
```

在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：

```
void * pvoid;
((char *)pvoid)++; //ANSI：错误；GNU：正确
(char *)pvoid += 1; //ANSI：错误；GNU：正确
```

GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。 如果函数的参数可以是任意类型指针，那么应声明其参数为void *

注：void指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为void指针，这样函数就可以接受任意类型的指针。如：

典型的如内存操作函数memcpy和memset的函数原型分别为：

```
void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );
```

 这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型（参见[C语言实现泛型编程](http://www.cnblogs.com/archimedes/p/c-general-function1.html)）。如果memcpy和memset的参数类型不是void *，而是char *，那才叫真的奇怪了！这样的memcpy和memset明显不是一个“纯粹的，脱离低级趣味的”函数！void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。

## `cpp`以空行结束

[地址] :  https://www.zhihu.com/question/20018991/answer/15239139

有一点是从 Python 中发现的,  就是最后一行都得空着,  也就是说,  代码的结束之后得多敲一个'\n' , 否则报错 :

> no newline at end of file

原因如下:



C 语言是在 Unix 中发明的，为 Unix 系统的编程语言，它对文件的处理遵循一个基本的原则：

> 文件是流式的，可以被任意的拼接并且拼接后仍然保证完整性。

为了保证这一点，在 Unix 中 \n 符号被定义为一行的『结束符』，换句话说，如果一行的结尾没有 \n 视为这一行没有结束，换句话说这个文件不完整，也就是说这根本不是一个合法的文本文件。（题外话：同时为了保证这一点，**Unix 文本通常不允许使用 BOM**，**因为 BOM 拼接之后将出现在字符流的中间位置**，**无法有效的定义其处理方法**。）

在 Windows 中，微软把 \n 定义为两行之间的『分隔符』而非结束符，所以 Unix 文件结尾的 \n ，在 Windows 看起来就是一个空行，而这一个空行在 Unix 中并不存在，如果你使用 Vim 之类的文本编辑器，会根本看不到最后这个空行。

不遵守标准会带来的问题是：如果 \n 是两行之间的分隔符，那么最后一行不带 \n，结果是拼接两个文件时，后一个文件的第一行就会被拼到前一个文件的最后一行，这很可能会造成语意错误。

比较常见的例子是：

前一个文件最后一行是 } 后一个文件第一行是 #include，如果 } 后面没有结束符，拼接之后就成了 }#include ，立即发生语法错误。


## 降低耦合



**date：**2020-05-28 00:00:00

**[来源]：**

1. 1. http://blog.csdn.net/tianyaxingge/article/details/6696114
    2. https://www.cnblogs.com/candyzhmm/p/7119690.html**
        **

### 0x01 耦合度

模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。

比如说若函数A依赖于函数B的实现中某个细微的对于全局变量的副作用，那么我们可以说A和B之间的耦合很深；这可能导致我们简单地修改了B之后发现A不能正常工作 了；可能会花费我们大量的时间来寻找原因。

就像是不会写网页的自己写了许多耦合度巨大的网页，而当时我改一个样式，另外一个区域的样式也就改变了，折腾了一天只写了一点点代码，而且还是不能用，最后结果还是全部删除重新开写。

**注：**“模块”一词是一个模糊的概念，可以是一个变量、一个函数、一个类，或者是一个package（在大型软件项目中）





强度依赖于以下几个因素：

1. 对另一个模块的调用；
2. 另一个模块传递的数据量；
3. 施加到另一个模块的控制的多少；
4. 接口的复杂程度。



耦合按从强到弱的顺序可分为以下几种类型：

1. 内容耦合。当一个模块直接修改或操作另一个模块的数据,或者直接转入另一个模块时，就发生了内容耦合。此时，被修改的模块完全依赖于修改它的模块。类与类之间直接调用或继承关系都是属于这种耦合。
2. 公共耦合。两个及两个以上的模块共同引用一个全局数据项就称为公共耦合。
3. 控制耦合。一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。
4. 标记耦合。模块间通过参数传递复杂的内部数据结构，称为标记耦合。此数据结构的变化将使相关的模块发生变化。
5. 数据耦合。模块间通过参数传递基本类型的数据，称为数据耦合。
6. 非直接耦合。模块间没有信息传递时，属于非直接耦合。



### 0x02 重要性

　**耦合度很高**的情况下，**维护代码时修改一个地方会牵连到很多地方，如果修改时没有理清这些耦合关系，那么带来的后果可能会是灾难性的**，特别是对于需求变化较多以及多人协作开发维护的项目，修改一个地方会引起本来已经运行稳定的模块错误，严重时会导致恶性循环，问题永远改不完，开发和测试都在各种问题之间奔波劳累，最后导致项目延期，用户满意度降低，成本也增加了，这对用户和开发商影响都是很恶劣的，各种风险也就不言而喻了。

值得注意的是，**不可能有绝对的零耦合**，比如基于J2EE编程那就必须和JDK耦合，而且高耦合也不是一无是处，如果在设计前期预料到某功能后期基本不用修改，那么即使高耦合了也关系不大。但是，在还没有能力设计出基本不用修改的代码前，还得要求以低耦合为标准。那么怎样才能最大限度地降低耦合度呢？下面介绍降低耦合度的几种方法。





### 0x03 方法

1. 少使用类的继承，多用接口隐藏实现的细节。 java面向对象编程引入接口除了支持多态外， 隐藏实现细节也是其中一个目的。 
2. 模块的功能化分尽可能的单一，供其它模块调用的机会就少。(高内聚低耦合)
3. 遵循一个定义只在一个地方出现。
4. 少使用全局变量 ("Singleton") 。
5. 类属性和方法的声明少用public，多用private关键字。
6. 多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。
7. 尽量不用“硬编码”的方式写程序，同时也尽量避免直接用SQL语句操作数据库。
8. 避免直接操作或调用其它模块或类（内容耦合）；如果模块间必须存在耦合，原则上尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，避免使用内容耦合。
9. 不要过早在意细节优化。先用最清楚的逻辑描述出程序的框架，如果真的有时间效率问题那一般来说是算法复杂度的问题，在程序编好且正确之后再考虑细节优化吧。这是耦合度增加的温床。
10. 面向对象。

> 我知道很难让人像我一样，每当要在程序中用到某种数据结构——不管是最简单的队列还是复杂些的并查集或者Suffix Tree——我都会编一个class，而且很可能是Template Class。我并不是炫耀，我只是想减少耦合，我只是想使程序更清晰些。“面向对象”这个话题会在本系列中单列一篇文章来做更详尽的分析。
>
> 我不知道你是否听说过UML、MVC等等这些在软件工程界很“时髦”的缩写词。我认为这些技术（尤其是MVC）存在的主要目的就是为了减少耦合。所以说，不要再写像涂了胶水的绳结一样的程序了，试图减少耦合，从今天开始。



[^1]: https://www.zhihu.com/question/22826568/answer/318102471
[^2]: https://blog.csdn.net/guhaoxin/article/details/83518679
[^3]: https://baike.baidu.com/item/Exit%28%29/1883141
[^4]: https://www.cnblogs.com/qicosmos/p/4283455.html
[^5]: http://blog.sina.com.cn/s/blog_78955cec0101lame.html
[^6]: https://www.cnblogs.com/wuyudong/p/c-void-point.html