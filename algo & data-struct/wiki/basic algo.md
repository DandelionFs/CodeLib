<center><font color=grey size=2>2020‎-0‎1‎-0‎1-30‎ ‎20:42:39</center>

### Preface

> 学习数据结构和算法其实是明白数据的存储结构和操作逻辑，然后更好的去实现代码的编辑。

函数原型 : 

> 函数原型( **Function prototype** ) 或**函数接口**（**Function interface**）是用于**指定函数的名称和类型特征**（元数，参数的数据类型和返回值类型）的一种省略了函数体的函数声明。虽然函数声明规定了函数是如何被实现的，但仅包括对接口的定义（即接受的数据类型和返回的数据类型），并不包括对函数体的定义。
>
> 函数原型被广泛应用于C、C++ 语言程序代码的上下文中，**通过在头文件中放置函数的前向声明来允许将代码拆分为多个翻译单元**。即**编译器可以单独编译目标文件的这部分内容,然后由链接器组合成可执行文件或库**。现代编译器（如Arduino IDE）不再需要函数原型，因为这些是在编译时确定和声明的。
>
> 在原型中，参数名是可选的（C/C++中存在函数原型作用域，这使参数名的作用域被限制在函数定义内），但是，类型和修饰符都是必需的（如指针或常量参数）。xz

### Define 

1. 多语句的宏定义可以写成：

```cpp
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;
```

​	int size = sizeof(a) / sizeof(int);是否有必要??????

```cpp
char p[10];
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++)cin>>p[i];
	cout<<strlen(p)<<endl;
	int size=sizeof(p)/sizeof(char);
	cout<<size<<endl;
} 
```




然后看一个例子

```c
// C语言内置的qsort函数
#include <stdio.h>      /* printf */
#include <stdlib.h>     /* qsort */
int values[] = { 40, 10, 100, 90, 20, 25 };
int compare(const void* a, const void* b){
	return (*(int*)a - *(int*)b);
}
int main(){
	int n;
	qsort(values, 6, sizeof(int), compare);
	for (n = 0; n < 6; n++) printf("%d ", values[n]);
	return 0;
}
```

 注意：

1. **函数原型** 
   ```cpp
   void qsort(
       void *base,//指向数组的起始地址，通常该位置传入的是一个数组名
       size_t nmemb,//表示该数组的元素个数
       size_t size,//表示该数组中每个元素的大小（字节数）
       int (*compar)(const void *, const void *)//此为指向比较函数的函数指针，决定了排序的顺序。（作为回调函数使用	）
   );
   ```

   <font color="red"> 如果两个元素的值是相同的，那么它们的前后顺序是不确定的。也就是说qsort()是一个不稳定的排序算法。 </font>

2. 上述中的决定排序顺序的比较函数: **compar**参数指向一个比较两个元素的函数。 在compar函数内部会将const void *型转换成实际类型
   `int compar(const void *p1, const void *p2);` 
   如果compar返回值小于0（< 0），那么p1所指向元素会被排在前面
   如果compar返回值等于0（= 0），那么p1指向元素与p2指向元素的顺序**不确定**
   如果compar返回值大于0（> 0），那么p2所指向元素会被排在前面
   **也就是说默认是升序序列**，换序直接作用于比较函数即可。

3. 回调函数：（函数的多层叠加） 通过函数指针调用的函数。 如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。

竞赛中的排序有三种：分别是C库的qsort，C++库的sort（第一种是传入一个 functor 对象，另外一种是直接传入一个排序函数），经过下面代码的运行

```c++
using namespace std;
#define _for(i,a,b) for(int i=(a);i<(b);++i)
const int N = 10000000;
struct TS {
	int a, b, c;
};
inline bool cmp(const TS& t1, const TS&t2) {
	if (t1.a != t2.a)return t1.a < t2.a;
	if (t1.b != t2.b)return t1.b < t2.b;
	return t1.c < t2.c;
}
int cmp4qsort(const void* a, const void* b) {
	TS* t1 = (TS*)a, * t2 = (TS*)b;
	if (t1->a != t2->a)return t1->a - t2->a;
	if (t1->b != t2->b)return t1->b - t2->b;
	return t1->c - t2->c;
}
struct cmpFunctor {
	inline bool operator()(const TS& t1, const TS& t2) {
		if (t1.a != t2.a)return t1.a < t2.a;
		if (t1.b != t2.b)return t1.b < t2.b;
		return t1.c < t2.c;
	}
};
TS tss[N];
void genData() {
	_for(i, 0, N) {
		tss[i].a = rand();
		tss[i].b = rand();
		tss[i].c = rand();
	}
}
int main() {
	srand(time(NULL));

	genData();
	clock_t start = clock();
	sort(tss, tss + N, cmp);
	printf("sort by functor pointer: %ld\n", clock() - start);

	genData();
	start = clock();
	sort(tss, tss + N, cmpFunctor());
	printf("sort by functor: %ld\n", clock() - start);

	genData();
	start = clock();
	qsort(tss, N, sizeof(TS), cmp4qsort);
	printf("qsort by functor pointer: %ld\n", clock() - start);

	return 0;
}
```

**运行结果**
`sort by functor pointer: 27337（36732）（C 5515）(D 3200)
sort by functor: 25326（6324）（C 3408）(D 3106)
qsort by functor pointer: 9481（15996）（C 3071）(D 2884)`

不知道为什么和作者的测试效果不一样，我的这个编译器（VS2019）测出来qsort是最快的，这点值得商榷。传入排序函数是最慢的这一点是相同的。已经有点混乱了，程序应该是没有问题的呀？和作者测试的不一样，这里先存疑吧？？？

笔者的机器上测试发现，STL 的 sort 使用 functor 的版本是最快的，比 qsort 都快一倍多。而使用 sort 传入函数指针的版本速度是最慢的，相对于前两者有大约 6 倍和 3 倍的差距，会在一些对排序性能要求很高的题目中形成比较明显的瓶颈，提醒读者注意。



### 读取一行类函数

#### `get()`成员类函数

该函数有几种变体，其中一种`cin.get()`可用来接收一行字符串，可接收空格,自动接收一个 ‘\0’

 ```cpp
char p[1000];
cin.get(p, 100);    
cout << p ;
 ```

 cin.get(无参数) :用于舍弃输入流中不需要的字符，或者舍弃回车，弥补cin.get(字符数组名，接收字符数)的不足

```cpp
char a, c;
cin >> a;
cin.get(c);
while (getchar() != '\n')
cout << a;
cout << c;
```

对于没有窗口停留的编译器最好加上以下两行代码：

```c++
    cin.get();//add this statement 
    cin.get();//and maybe this, too 
    return 0;
```

cin.get（）语句读取下一次键击，因此上述语句让程序等待，直到按下了Enter键（在按下Enter键之前，键击将不被发送给程序，因此按其他键都不管用）。如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。例如，如果要输入一个数字，则需要输入该数字，然后按Enter键。程序将读取该数字，但Enter键不被处理，这样它将被第一个cin.get（）读取。

get()家庭还有这个？具体是什么暂时还不太清楚？

```cpp
#include<conio.h>
#include<iostream>
using namespace std;
int main() {
	char p;
	p = getche();
	cout << endl << p;
}
```

fgets函数——get_s（）得到一个包含空格的字符串？？？？

#### `getline()`成员函数

:接收一个字符串，可以接收空格并输出,自动接收一个 ‘\0’ 

**cin.getline(接收字符串,接收个数，(结束字符))**

```cpp
char p[100];
cin.getline(p, 100);
cout << p;
```

**注意：**getline :接收一个字符串，可以接收空格并输出。用`getline`处理`string`而不是字符数组的时候，需包含头文件 #include <string>，因为`<iostream>`头文件中包含操作字符数组的预处理信息（ cin.getline() 属于 iostream 流，而 getline() 属于 string 流，是不一样的两个函数）。

---

`get()（fgets、cin.get()）`和`getline()`的区别：

> `istream`中的类（如`cin`）提供了一些面向行的类成员函数：`getline()`和`get()`，这两个函数都读取一行输入，直到到达换行符。然而，随后`getline()`将丢弃换行符，而`get()`将换行符保留在输入序列中。——《C++ Primer Plus》

 特别注意：这里我再补充一点`cin.getline`是读取换行符的，只是保存的时候将换行符丢弃了，保存的数组中换行符`\n`变成了 `\0.`但是`cin.get()`则不同，它不再读取并丢弃换行符，而是将其留在输入队列中。测试代码如下：

```cpp
#include <iostream>
using namespace std;
int main() {
	char p[5];
	cin.get(p,5);//cin.getline(p,5)
	char m = cin.get();
	cout << p << endl;
	cout << m;
}
```

由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此`get()`认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，`get()`将不能跨过该换行符。

幸运的是，`get()`有另一种变体——`cin.get（）`调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，平时敲代码的时候常常出现的下面的调用序列：

 ```cpp
cin.get(p,50);
cin.get();
cin.get(q,50);
//还有一种方式把1和2连接前来
cin.get(p,50).get();
cin.getline(p1,50).getline(p2,50);
 ```

之所以可以这样做，是由于`cin.get（p,50）`返回一个cin对象，该对象随后将被用来调用`get()`函数。同样下面的语句将把输入中连续的两行分别读入到数组p1和p2中，其效果与两次调用`cin.getline()`相同。有趣的是还有一种读取类似于`cin.get()`，那就是`getchar()`。类似的行为还存在于数字和字符串混合输入的时候，需要在数字后面先把换行符吃掉，才可以正常的读取一行的操作。

 ```cpp
char ch = cin.get();
cout << ch;
char zh =getchar();
cout<<zh;
（cin>>year）.get();
cin.getline(p,50);
 ```

但是有一点要声明的是：`ctrl+z`读取回来的值是`-1`，空格读取回来是ASKII的值`32`,h下面是我的测试代码： `cout << getchar();` 。为什么要使用get()，而不是getline()呢？

1. 老式实现没有`getline()`。

2. get()使输入更仔细。
    例如，假设用get()将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。

总之，getline()使用起来简单一些，但get()使得检查错误更简单些。可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。

疑点：空行和其他问题：

> 当getline()或get()读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取；但当前的做法是，当get()（不是getine()读取空行后将设置失效位(failbit)，这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：cin.clear()；另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline()和get()将把余下的字符留在输入队列中，而getline()还会设置失效位，并关闭后面的输入。
>
> 还是不太懂失效位(failbit)？？？？是做什么的？？？？

#### Puts的操作

这里还是不太清楚，先上代码：

```cpp
#include <stdio.h>
using namespace std;
int main(){
    char s[81];
    int i;
    gets(s);
    for (i = 0; s[i] != '\0'; i++){
        if (s[i] >= 'a' && s[i] <= 'z'){
            if (s[i] == 'z') s[i] = 'a';
            else s[i] += 1;
        }
    }
    puts(s);
    return 0;
}
```

### 字符串读写

这里笔者搞错了一个数组的概念……自愧弗如，数组是申请一段连续的内存，`a[10]`申请到的内存是`a[0]`到`a[9]`，是没有`a[10]`的，这里下标就是一个误区，因为以前总是喜欢数组开1000，所以根本没有时注意这点。

也就是说，如何你要读取11位的数字（手机号码），你要开的内存大小最少是12`p[12]`，读取也是12`cin.getline(p,12)`，不存在说p[12]和p[11]都是空的疑问…………

#### 读取字符串

```c++
int main() {	
	char p[5];
	cin.getline(p, 5);//准确来说读取的位数是4位+'\0'一共五位，四位有效数字
	cout << p << endl;
}
```

如注释所言，这样控制的数量只可以是读取有效的四位而已，如果要读取五位数字，就要定义6大小的数组。

#### 字符数组整体命名

```c++
int main() {
	char w[5] = { 'Dang' };
	cout << w<<"\n";
	char p[] = { "Dang" };
	cout << p;
}
```

注意的一点就是要用双引号（单引号会变成那个串的最后一个字母!!!枯了）

#### 不确定数组的大小

字符数组那自不必我多说是用`strlen(p)`来确定，但是同样的，可以用`sizeof(p)/sizeof(char)`来确定



### 动态二维数组的申请

#### 申请

好处不由分说，传递指针比传递整个对象更方便高效；随时确定存储大小，避免内存浪费。C++建立动态二维数组主要有两种方法：

1. 多维动态数组的申请是由高级指针+for循环实现，先依次声明维度的大小，然后从最低维度开始申请内存，其内存释放则是由内到外不断释放的。使用数组指针，分配一个指针数组，将其首地址保存在b中，然后再为指针数组的每个元素分配一个数组。

    ```cpp
    int **b=new int*[row];//分配一个指针数组，将其首地址保存在b中
    for(i=0;i<row;i++) b[i]=new int[col];//为指针数组的每个元素分配一个数组。
    ```

2. 利用`vector`.

    ```cpp
    vector<vector<int> > a(row,vector<int>(column));
    ```

    注意：在当函数的数组定义功能被不断的函数调用而不进行内存的释放的时候，就会导致软件奔溃。

#### 释放

释放动态数组时，使用`delete[]Dynamic_Arr4;`即在数组名前加上一个中括弧。这个时候的中括弧，或者说是指向数组的指针时，空括号是必须的。它告诉编译器，指针指向一个数组的第一个元素。需先释放指针数组的每个元素指向的数组，然后再释放该指针数组：

```cpp
for(i=0;i<row;i++){
   delete []b[i];
   b[i]=NULL;
}
delete []b;
b=NULL;
```

delete释放数组是逆序进行的，最后一个元素被最先释放，第一个元素最后一个被释放。

```cpp
 for (int i = 0; i < MAX_NUM; i++){
     for (int j = 0; j < ROW_NUM; j++){
         delete[] Arr3D[i][j];
     }
     delete[] Arr3D[i];
 }
delete[] Arr3D;
```

#### 内存使用的问题

```cpp
A a;//直接将a放入栈区(局部变量，大小受限，自动释放)； 
A * a = new A();//在堆区(动态内存，大小任意，手动释放)分配一块内存，然后用指针a去指向
```

#### 动态申请的显示初始化

```cpp
string* Dynamic_Arr4 = new string[size]{"aa", "bb","cc", "dd", string(2, 'e') };      
```

**显式初始化可能会因为编译器版本原因报错，笔者在VS2013与VS2017下进行测试，VS2013下在释放内存时出现内存错误。**

测试代码：

```cpp
void not_delete_fun(){
	int* arr_test = new int[10];
	cout << arr_test << endl;
	//delete[] arr_test;
}
void delete_fun(){
	int* arr_test = new int[10];
	cout << arr_test << endl;
	delete[] arr_test;
}
int main(){
	int* Dynamic_Arr1 = NULL;
	Dynamic_Arr1 = new int[10];
	int size = 10;
	int* Dynamic_Arr2 = new int[size];       //未初始化;
	int* Dynamic_Arr3 = new int[size] {10, 9, 2, 8, 3, 6, 4};     //默认的初始化；
	string a = "ee";
	string* Dynamic_Arr4 = new string[size]{ "aa", "bb", "cc", "dd", string(1, 'e'), "aa", "bb", "cc", "dd", string(2, 'e') };      //显式的初始化
	//string *Dynamic_Arr4 = new string[size];
	//cout << Dynamic_Arr4[4] << endl;
	cout << "未释放内存的数组位置" << endl;
	for (int i = 0; i < 3; i++){
		not_delete_fun();
	}
	cout << "释放过内存的数组位置" << endl;
	for (int i = 0; i < 3; i++){
		delete_fun();
	}
}
```

多维数组的存储和释放:

```cpp
int main() {
	int MAX_NUM = 10;
	int COL_NUM = 5, ROW_NUM = 3;
	double*** Arr3D = new double** [MAX_NUM];
	for (int i = 0; i < MAX_NUM; i++){
		Arr3D[i] = new double* [ROW_NUM];
		for (int j = 0; j < ROW_NUM; j++){
			Arr3D[i][j] = new double[COL_NUM];
		}
	}
	//cout << Arr3D[9][4][2] << endl;
	for (int i = 0; i < MAX_NUM; i++){
		for (int j = 0; j < ROW_NUM; j++){
			delete[] Arr3D[i][j];
		}
		delete[] Arr3D[i];
	}
	delete[] Arr3D;
	delete[] Dynamic_Arr1;
	delete[] Dynamic_Arr2;
	delete[] Dynamic_Arr3;
	delete[] Dynamic_Arr4;
	system("pause");
	return 0;
}
```











### 两个冒号的操作

一个冒号有这样的特点，那你能说出**两个冒号的特点吗**？

1.  全局作用域符号
   当全局变量在局部函数中与其中某个变量重名时，可以用::来区分，否则局部变量会屏蔽全局变量。

   ```c++
   int a = 10;
   int main() {
   	int a = 100;
   	cout << a << endl;
   	cout << ::a;
   }
   ```

2. 作用域符号 
   前面一般是该类名称，后面是该类的成员名称。C++为避免不同的类有相同的成员而采用作用域的方式进行区分，eg：A，B表示两个类，在A，B中都有成员member，那么：A::member表示A中的成员member，B::member表示B中的成员member。 

3.   作用域分解运算符 

   比如声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f函数的定义，那么在类外定义f时，就要写成void A::f()，表示这个f函数是类A的成员函数。 

### 全局数组大小[^2][^3]

> 全局数组到底可以开多大？为什么局部数组就不可以开大？

**[原理]：**涉及C语言的内存分配问题，C语言占用的内存可以分为5个区：

> 1. **代码区（Text Segment）**：用于放置编译过后的代码的二进制机器码。

<br/>

> 2. **堆区（Heap）**
>
> **特点**：first in first out，fifo。
>
> **地址空间** ：“向上增加” ，即保存的数据越多，堆的地址就越高。
>
> **功能：**用于动态内存分配。由程序员分配和释放，若不释放，当结束程序时可能由OS回收。而长时间不释放易导致“内存泄漏”。（其实就是malloc()函数能够掌控的内存区域）
>
> **注：**和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。 32位以上的操作系统支持“虚存”.

<br/>

>
>   3. **栈区（Stack）**
>
> **特点**：向低地址扩展的数据结构，是一块连续的内存的区域。即**栈顶的地址**（在可读写的ram区的最后。是为执行线程留出的内存空间）和**栈的最大容量**是**系统预先规定**好的。last in first out，lifo。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的
>
> **地址空间：**“向下减少”，即当栈上保存的数据越多，栈的地址就越低。
>
>**功能：**一般用来存放局部变量、函数参数，由编译器自动分配和释放。
>
>**性质：**附属于**线程**，当线程结束时栈被回收。
>
> **场景：**   函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。
>
> **注：**   16位模式下有段的概念,一个段只有64K。所以任何连续数据都不能超过这个尺寸。
>

<br/>

>   4. **全局初始化数据区/静态数据区（Data Segment）**
>   
>**功能：**存放**全局变量和静态变量**。初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
> 
>**特点：**这个区域被整个进程共享。

<br/>

>   5. **未初始化数据区（BSS,block started by symbol）**
>
> **特点：**初始化值得时候全局变量和静态变量待的地方，运行时改变值的同时根据自身属性进入上面的区域
>
> **注：**数组在局部初始化的时候会赋予随机数（乱码），但是变量不会，如果没有没定义多大就会显示类似`Not limited`的错误。**常量字符串就是放在这里的。 程序结束后由系统释放** 

<br/>

总之。研究这个意义不大，不同编译器，可能行为不同。在Windows下，Data Segment（静态数据区）的所允许的空间大小取决于剩余内存的大小，也就是说，如果电脑剩余8G内存的话，int类型的二维数组甚至可以开到`46340*46340`的大小； 而 Stack（栈区）的空间只有<font color="red">2M！(这里我在用VS编译的时候好像是VS自定义了一个比2M小得多的栈区，经过蛋疼测试，极限是`int p[258298]``258298*4/1024/1024=0.98532M`大小，大概是1M的大小，可以用连接器参数`/STACK:reserve[,commit]`调整栈大小)</font>也就是 `2*1024*1024=2097152字节`，局部变量空间顶多放得下下524288个int类型（数组大概是`724.077*724.077`）！知道上述几个关键后，一开始的问题就不是问题了。但我想在局部中开一个大数组怎么办？很简单，将它归到Data Segment中：

```cpp
#include<iostream>
using namespace std;
int main(){
    static int dis[8000][8000];//注意局部变量的初始化
}
```

而在局部定义数组的时候，数组会自动初始化为随机数，所以数组在刚被定义的时候就塞进Stack区了，才会出现int dis[520073]直接报堆栈溢出的问题。如果需要大量的内存.建议使用new在堆上创建对象().或者直接使用windowsAPI VirtualAlloc,GlobalAlloc等自己从系统堆上分配.（自己暂时还不明白……）

引用他人写的cpp：

```cpp
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
int main() { 
	int b; //栈 
	char s[] = "abc"; //栈 
	char *p2; //栈 
	char *p3 = "123456"; //123456在常量区，p3在栈上。 
	static int c =0； //全局（静态）初始化区 
	p1 = (char *)malloc(10); 
	p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
}
```

这里主要区别对比一下堆和栈：

1. 申请机制：
   **栈**：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

   **堆**：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 
   会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

2. 大小限制 ：

   **栈**：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在  WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

   **堆**：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

3. 效率比较：
   **栈**由系统自动分配，速度较快。但程序员是无法控制的。 

   **堆**是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 
   另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度， 也最灵活 

4. 存储内容 
   **栈**： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 
   当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
**堆**：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
   
5. 每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。


效率比较实例：

```cpp
char s1[] = "aaaaaaaaaaaaaaa"; //aaaaaaaaaaa是在运行时刻赋值的； 
char *s2 = "bbbbbbbbbbbbbbbbb"; //bbbbbbbbbbb是在编译时就确定的； 
```

在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 这个可以用编译后的汇编代码查看操作来敲定到底做了什么。（Flag）



<font color="red">**理性分析：**</font>

回归这道题目，具体开多大根据题目给的内存进行处理，如：`8000*8000*4/1024/1024≈244 MB`.`8192*8192*4/1024/1024≈256 MB`.普通题目最大可以开到8129的大小。考虑要用到的局部变量的话，一个局部变量是`1*4/1024/1024=0.0000038MB`,相对而言比较大的局部变量是他的二倍，不过`0.0000076MB`.明显占不到什么内存。

### 运算符的优先顺序

之前写了一个程序

```cpp
int main() {
	int a, b, c;
	a = 1, b = 0, c = 1;
	if (a == b == c==0) cout << "Y";
    cout<<endl;
    a = 1, b = 1, c = 1;
	if (a == b == c==0) cout << "Y";
}
```

居然给我输出`Y`……

于是上网找了找资料……涉及到了运算符的结合顺序，

> 先执行a`==`b结果是（true或false）再和c比。那么c的`==`是和a`==`b的结果进行比较而已。

所以自己从左面一步一步算到右面居然就是正确的……以下附上C++运算符优先级以及结合表，以前都没有这么注意过这个……：

| 优先级 |   运算符   |      名称或含义       |         使用形式          | 结合方向 |          说明          |
| :----: | :--------: | :-------------------: | :-----------------------: | :------: | :--------------------: |
|   1    |     []     |       数组下标        |    数组名[常量表达式]     |  左到右  |                        |
|        |     ()     |        圆括号         | (表达式)  函数名(形参表)  |          | 函数调用<br />参数传递 |
|        |     .      |   成员选择（对象）    |        对象.成员名        |          |                        |
|        |     ->     | 成员指针选择（指针）  |     对象指针->成员名      |          |                        |
|        |     .*     |     成员指针选择      |                           |          |                        |
|        |    ->*     |     成员指针选择      |                           |          |                        |
|   2    |     -      |      负号运算符       |          -表达式          |  右到左  |       单目运算符       |
|        |   (类型)   |     强制类型转换      |     (数据类型)表达式      |          |                        |
|        |     ++     |      自增运算符       |    ++变量名  变量名++     |          |       单目运算符       |
|        |     --     |      自减运算符       |    --变量名  变量名--     |          |       单目运算符       |
|        |     *      |      取值运算符       |         *指针变量         |          |       单目运算符       |
|        |     &      |     取地址运算符      |          &变量名          |          |       单目运算符       |
|        |     !      |     逻辑非运算符      |          !表达式          |          |       单目运算符       |
|        |     ~      |    按位取反运算符     |          ~表达式          |          |       单目运算符       |
|        |   sizeof   |      长度运算符       |      sizeof(表达式)       |          |                        |
|        | new delect | 动态内存分配 释放内存 |                           |          |                        |
|   3    |     /      |          除           |      表达式 / 表达式      |  左到右  |       双目运算符       |
|        |     *      |          乘           |       表达式*表达式       |          |       双目运算符       |
|        |     %      |     余数（取模）      |   整型表达式%整型表达式   |          |       双目运算符       |
|   4    |     +      |          加           |       表达式+表达式       |  左到右  |       双目运算符       |
|        |     -      |          减           |       表达式-表达式       |          |       双目运算符       |
|   5    |     <<     |         左移          |       变量<<表达式        |  左到右  |       双目运算符       |
|        |     >>     |         右移          |       变量>>表达式        |          |       双目运算符       |
|   6    |     >      |         大于          |       表达式>表达式       |  左到右  |       双目运算符       |
|        |     >=     |       大于等于        |      表达式>=表达式       |          |       双目运算符       |
|        |     <      |         小于          |       表达式<表达式       |          |       双目运算符       |
|        |     <=     |       小于等于        |      表达式<=表达式       |          |       双目运算符       |
|   7    |     ==     |         等于          |      表达式==表达式       |  左到右  |       双目运算符       |
|        |     !=     |        不等于         |      表达式!= 表达式      |          |       双目运算符       |
|   8    |     &      |        按位与         |       表达式&表达式       |  左到右  |       双目运算符       |
|   9    |     ^      |       按位异或        |       表达式^表达式       |  左到右  |       双目运算符       |
|   10   |     \|     |        按位或         |      表达式\|表达式       |  左到右  |       双目运算符       |
|   11   |     &&     |        逻辑与         |      表达式&&表达式       |  左到右  |       双目运算符       |
|   12   |    \|\|    |        逻辑或         |     表达式\|\|表达式      |  左到右  |       双目运算符       |
|   13   |     ?:     |      条件运算符       | 表达式1? 表达式2: 表达式3 |  右到左  |       三目运算符       |
|   14   |     =      |      赋值运算符       |        变量=表达式        |  右到左  |                        |
|        |     /=     |       除后赋值        |       变量/=表达式        |          |                        |
|        |     *=     |       乘后赋值        |       变量*=表达式        |          |                        |
|        |     %=     |      取模后赋值       |       变量%=表达式        |          |                        |
|        |     +=     |       加后赋值        |       变量+=表达式        |          |                        |
|        |     -=     |       减后赋值        |       变量-=表达式        |          |                        |
|        |    <<=     |      左移后赋值       |       变量<<=表达式       |          |                        |
|        |    >>=     |      右移后赋值       |       变量>>=表达式       |          |                        |
|        |     &=     |     按位与后赋值      |       变量&=表达式        |          |                        |
|        |     ^=     |    按位异或后赋值     |       变量^=表达式        |          |                        |
|        |    \|=     |     按位或后赋值      |       变量\|=表达式       |          |                        |
|   15   |     ,      |      逗号运算符       |      表达式,表达式,…      |  左到右  |                        |

下表就整理了优先级同为1 的几种运算符如果同时出现的情况：

| 优先级问题                                    | 表达式                 | 经常误认为的结果                                         | 实际结果                                                     |
| :---------------------------------------------: | :----------------------: | :--------------------------------------------------------: | :------------------------------------------------------------: |
| . 的优先级高于 *（-> 操作符用于消除这个问题） | `*p.f`                 | p 所指对象的字段 f，等价于：  (*p).f                     | 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于：  *(p.f) |
| [] 高于 *                                     | `int *ap[]`            | ap 是个指向 int 数组的指针，等价于：  int (*ap)[]        | ap 是个元素为 int 指针的数组，等价于：  int *(ap [])         |
| 函数 () 高于 *                                | `int *fp()`            | fp 是个函数指针，所指函数返回 int，等价于：  int (*fp)() | fp 是个函数，返回 int*，等价于：  int* ( fp() )              |
| == 和 != 高于位操作                           | `(val & mask != 0)`    | (val &mask) != 0                                         | val & (mask != 0)                                            |
| == 和 != 高于赋值符                           | `c = getchar() != EOF` | (c = getchar()) != EOF                                   | c = (getchar() != EOF)                                       |
| 算术运算符高于位移 运算符                     | `msb << 4 + lsb`       | (msb << 4) + lsb                                         | msb << (4 + lsb)                                             |
| 逗号运算符在所有运 算符中优先级最低           | `i = 1, 2`             | i = (1,2)                                                | (i = 1), 2                                                   |

### 结构体下嵌套表达式错位[^4][^5]

写一个程序如此这般

```cpp
typedef struct Stu {
	char id;
	string name;
}S;
int main() {
	int N, k, i = 0;
	cin >> N, k = N;
	S* p = new S[N];
	while (k--) cin >> p[i].id >> p[i++].name;
	for (i = 0; i < N; i++) {
		cout << p[i].id << " " << p[i].name << endl;
	}
//  ......
}
/*
程序写了一半
3
1 zhangsan
2 lisi
3 wangwu
*/
```

测试一下发现不对，在我的VS2019中测试结果是：

```cpp
?zhangsan
1 lisi
2 wangwu
```

有点懵逼，请教完师傅后明白了，是c++中如果函数的参数列表包含多个实参，那么对参数的求值顺序是不确定的。即编译器对函数的嵌套表达式求值方向是不一样的，即使是同一个编译器在不同情况下也会不一样，而且在每一次变换的情况下最终结构也大相径庭，所以在实际使用中，要尽量避免一个语句中包含多个表达式的情况，或者保证多个表达式之间不存在互相影响结果的情况。

> cin其实是个写法特殊的函数，`pi.id`和`pi.name`其实是它的两个参数，c++参数求值顺序不确定，例如 f(a,a++);假设a的值为10，如果先左后右 就是10、10 ，然后a变11，如果先右后左 就是11、10。这一点c++标准里没规定，所以不同厂商的编译器在处理库函数和自定义函数时处理方法各异，解决办法为：涉及到函数调用实参间时，避免使用。

博主测试代码（转）：

```cpp
void test(int x, int y) {
	cout << 'x' << x << " y" << y << endl;
}
int main() {
	int i = 3;
	test(i, i++);
	i = 3, test(i, ++i);
	i = 3, test(i++, i);
	i = 3, test(++i, i);
}
```

最终结果：

```cpp
x4 y3
x4 y4
x3 y4
x4 y4
```

### 快速范围判断[^6]

+ 批量判断某些值在不在范围内，如果 int 检测是 [0, N) 的话：

    ```cpp
    if (x >= 0 && x < N) ... # Normal
    if (((unsigned int)x) < N) ...#  CPU 优化->减支
    ```

+ 如果 int 检测范围是 [minx, maxx] 这种更常见的形式

    ```cpp
    if (x >= minx && x <= maxx) ...
    if (( (x - minx) | (maxx - x) ) >= 0) ... # 用比特或操作继续减少判断次数
    if ((int32_t)(((uint32_t)x - (uint32_t)minx) | ((uint32_t)maxx - (uint32_t)x)) > = 0) ...# 担心有符号整数回环是未定义行为
    ```

性能相同，但避开了有符号整数回环，改为无符号回环，合并后转为有符号判断最高位。

第一个 (x - minx) 如果 x < minx 的话，得到的结果 < 0 ，即高位为 1，第二个判断同理，如果超过范围，高位也为 1，两个条件进行比特或运算以后，只有两个高位都是 0 ，最终才为真，同理，多个变量范围判断整合：

```cpp
if (( (x - minx) | (maxx - x) | (y - miny) | (maxy - y) ) >= 0) ...
```

这样本来需要对 [x, y] 进行四次判断的，可以完全归并为一次判断，减少分支。

补充：加了个性能评测：

性能提升 37%。快速范围判断还有第二个性能更均衡的版本：

```cpp
if ((unsigned)(x - minx) <= (unsigned)(maxx - minx)) ...
```

快速范围判断的原理和评测详细见：《[快速范围判断：再来一种新写法](https://zhuanlan.zhihu.com/p/147039093)》。

### 更好的循环展开[^6]

很多人提了 duff's device ，按照 gcc 和标委会丧心病狂的程度，你们用这些 just works 的代码，不怕哪天变成未定义行为给一股脑优化掉了么？其实对于循环展开，可以有更优雅的写法：

```cpp
#define CPU_LOOP_UNROLL_4X(actionx1, actionx2, actionx4, width) do { \
    unsigned long __width = (unsigned long)(width);    \
    unsigned long __increment = __width >> 2; \
    for (; __increment > 0; __increment--) { actionx4; }    \
    if (__width & 2) { actionx2; } \
    if (__width & 1) { actionx1; } \
}   while (0)
```

送大家个代替品，CPU_LOOP_UNROLL_4X，用于四次循环展开，用法是：

```cpp
CPU_LOOP_UNROLL_4X(
    {
        *dst++ = (*src++) ^ 0x80;
    },
    {
        *(uint16_t*)dst = (*(uint16_t*)src) ^ 0x8080;
        dst += 2; src += 2;
    },
    {
        *(uint32_t*)dst = (*(uint32_t*)src) ^ 0x80808080;
        dst += 4; src += 4;
    },
    w);
```

假设要对源内存地址内所有字节 xor 0x80 然后复制到目标地址的话，可以向上面那样进行循环展开，分别写入 actionx1, actionx2, actionx4 即：单倍工作，双倍工作，四倍工作。然后主体循环将用四倍工作的代码进行循环，剩余长度用两倍和单倍的工作拼凑出来。

现在的编译器虽然能够帮你展开一些循环，CPU 也能对短的紧凑循环有一定预测，但是做的都非常傻，大部分时候你用这样的宏明确指定循环展开循环效果更好，你还可以再优化一下，主循环里每回调用两次 actionx4，这样还能少一半循环次数，剩余的用其他拼凑。

这样比 duff's device 这种飞线的写法更规范，并且，duff's device 并不能允许你针对 “四倍工作”进行优化，比如上面 actionx4 部分直接试用 uint32_t 来进行一次性运算，在 duff's device 中并没有办法这么做。

补充：《[循环展开性能评测](http://link.zhihu.com/?target=http%3A//quick-bench.com/RzDK1PTIciupI5aCq5esaPADGLU)》

性能提升 12% 。

另外还存在一种新的写法: 

```c++
int main() {
	int array[] = { 1,2,3,4,5,'\0' };
	for (int i : array)i *= 2;
	for (int i = 0; array[i] != '\0'; i++)cout << array[i] << " ";
	cout << endl;
	for (int &i : array)i *= 2;
	for (int i = 0; array[i] != '\0'; i++)cout << array[i] << " ";
}
```

 这里的运行结果是：

`1 2 3 4 5`
		`2 4 6 8 10`

这个循环大有来历，当初问老师老师也不承认这是C++的标准写法，但是整洁度还是让我比较向往这样的写法。

自己仿照这个循环自己写了一个小小的循环，这个循环叫foreach循环，是从Java引用过来的？！**是C++11的新特点**。其实还是有点懵逼

```c++
void printLOVE() {
	char arr[] = { 'I','O','E','V','L',' ','U','Y','O'};
	int index[] = { 0,5,4,1,3,2,5,7,8,6 };
	for (int i : index) {
		cout << arr[i];
	}
}
```

把数组 a中所有的数，一一 赋给 b,并且 每赋值一个数 执行{}中的 代码一次 

### 整数快速除以 255[^6]

整数快速除以 255 这个事情非常常见，例如图像绘制/合成，音频处理，混音计算等。网上很多比特技巧，却没有人总结过非 2^n 的快速除法方法，所以我自己研究了个版本：

```cpp
#define div_255_fast(x)    (((x) + (((x) + 257) >> 8)) >> 8)
```

当 x 属于 [0, 65536] 范围内，该方法的误差为 0。过去不少人简略的直接用 >> 8 来代替，然而这样做会有误差，连续用 >>8 代替 / 255 十次，误差就累计到 10 了。

上面的宏可以方便的处理 8-16 位整数的 /255 计算，经过测试 65536000 次计算中，使用 /255的时间是 325ms，使用div_255_fast的时间是70ms，使用 >>8 的时间是 62ms，div_255_fast 的时间代价几乎可以忽略。

进一步可以用 SIMD 写成：

```cpp
// (x + ((x + 257) >> 8)) >> 8
static inline __m128i _mm_fast_div_255_epu16(__m128i x) {
	return _mm_srli_epi16(_mm_adds_epu16(x, 
		_mm_srli_epi16(_mm_adds_epu16(x, _mm_set1_epi16(0x0101)), 8)), 8);
}
```

这样可以同时对 8 对 16 bit 的整数进行 / 255 运算，照葫芦画瓢，还可以改出一个 / 65535 ，或者 / 32767 的版本来。

对于任意大于零的整数，他人总结过定点数的方法，x86 跑着一般，x64 下还行：

```cpp
static inline uint32_t fast_div_255_any (uint32_t n) {
    uint64_t M = (((uint64_t)1) << 32) / 255;   // 用 32.32 的定点数表示 1/255
    return (M * n) >> 32;   // 定点数乘法：n * (1/255)
}
```

这个在所有整数范围内都有效，但是精度有些不够，所以要把 32.32 的精度换成 24.40 的精度，并做一些四舍五入和补位：

```cpp
static inline uint32_t fast_div_255_accurate (uint32_t n) {
    uint64_t M = (((uint64_t)1) << 40) / 255 + 1;   // 用 24.40 的定点数表示 1/255
    return (M * n) >> 40;   // 定点数乘法：n * (1/255)
}
```

该方法能够覆盖所有 32 位的整数且没有误差，有些编译器对于常数整除，已经可以生成类似 fast_div_255_accurate 的代码了，整数除法是现代计算机最慢的一项工作，动不动就要消耗 30 个周期，常数低的除法除了二次幂的底可以直接移位外，编译器一般会用定点数乘法模拟除法。

编译器生成的常数整除代码主要是使用了 64 位整数运算，以及乘法，略显复杂，对普通 32 位程序并不是十分友好。因此如果整数范围属于 [0, 65536] 第一个版本代价最低。

且 SIMD 没有除法，如果想用 SIMD 做除法的话，可用上面的两种方法翻译成 SIMD 指令。

255 快除法的《[性能评测](http://link.zhihu.com/?target=http%3A//quick-bench.com/t3Y2-b4isYIwnKwMaPQi3n9dmtQ)》

提升一倍的性能。

---

PS：大部分时候当然选择相信编译器，提高可读性，如果你只写一些增删改查，那怎么漂亮怎么写就行；但如果你想写极致性能的代码，你需要知道编译器的优化是有限的穷举，没法应对无限的代码变化，上面三个就是例子，编译器优化可以帮你，但没法什么都靠编译器，归根结底还是要了解计算机体系，这样脱开编译器，不用 C 语言，你也能写出高性能代码。

PS：不要觉得丧心病狂，你们去看看 kernel 里各处性能相关的代码，看看 pypy 如何优化 python 的哈希表的，看看 jdk 的代码，这类优化比比皆是，其实写多了你也不会觉得难解。

### 常数范围裁剪[^6]

有时候你计算一个整数数值需要控制在 0 - 255 的范围，如果小于 0 那么等于零，如果大于 255，那么等于 255，做一个裁剪工作，可以用下面的位运算：

```cpp
static inline int32_t clamp_to_0(int32_t x) { 
	return ((-x) >> 31) & x; 
}
static inline int32_t clamp_to_255(int32_t x) {
	return (((255 - x) >> 31) | x) & 255;
}
```

这个方法可以裁剪任何 2^n - 1 的常数，比如裁剪 65535：

```cpp
static inline int32_t clamp_to_65535(int32_t x) {
	return (((65535 - x) >> 31) | x) & 65535;
}
```

略加改变即可实现，没有任何判断，没有任何分支。本技巧在不同架构下性能表现不一，具体看实测结果。

**快速位扫描**

假设你在设计一个容器，里面的容量需要按 2 次幂增加，这样对内存更友好些，即不管里面存了多少个东西，容量总是：2, 4, 8, 16, 32, 64 的刻度变化，假设容量是 x ，需要找到一个二次幂的新容量，刚好大于等于 x 怎么做呢？

```cpp
static inline int next_size(int x) {
    int y = 1;
    while (y < x) y *= 2;
    return y;
}
```

一般会这样扫描一下，但是最坏情况上面循环需要迭代 31 次，如果是 64 位系统，类型是 size_t 的话，可能你需要迭代 63 次，假设你做个内存分配，分配器大小是二次幂增长的，那么每次分配都要一堆 for 循环来查找分配器大小的话，实在太坑爹了，于是继续位运算：

```cpp
static inline uint32_t next_power_of_2(uint32_t x) {
    x--;
    x |= x >> 1; 
    x |= x >> 2; 
    x |= x >> 4; 
    x |= x >> 8; 
    x |= x >> 16; 
    x++
    return x;
}
```

以及：

```cpp
static inline uint32_t next_power_of_2(uint64_t x) {
    x--;
    x |= x >> 1; 
    x |= x >> 2; 
    x |= x >> 4; 
    x |= x >> 8; 
    x |= x >> 16; 
    x |= x >> 32; 
    x++
    return x;
}
```

在不用 gcc 内置 `__builtin_clz` 函数或 bsr 指令的情况下，这是 C 语言最 portable 的方案。 





### More

+ [C++的数组可以int n;cin>>n;int a`n;`这样初始化吗](https://segmentfault.com/q/1010000006672117).



### Reference

#### books

1. 《C++ Primer Plus 中文（第六版）》
2. 《算法竞赛入门经典第三册——习题与解答》
3. **[Bjarne Stroustrup](http://www.research.att.com/~bs/homepage.html) 的 C++ 风格与技术 [FAQ](www.stroustrup.com/bsfaq2cn.html)（中文版）**
4. [C++ Style and Technique FAQ （中文版）](http://www.stroustrup.com/bstechfaq.htm)



[^1]: 
[^2]: [关于C语言开大数组溢出的问题](https://blog.csdn.net/qq_21882325/article/details/65445810).Leaviathan
[^3]: [局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别(转)](https://www.cnblogs.com/bakari/archive/2012/08/05/2623637.html).Linux云计算网络
[^4]: [c++中函数参数的求值顺序](https://www.cnblogs.com/Leon-Yan/p/7567766.html). Leon_Yan
[^5]: [[C/C++板块推荐阅读] 关于C,C++表达式求值顺序.]( https://bbs.csdn.net/topics/370153775) . 裘宗燕
[^6]: https://www.zhihu.com/question/27417946/answer/1253126563

