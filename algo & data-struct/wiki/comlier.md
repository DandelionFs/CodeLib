# C++ COMLIER(C++ 编译)
THX FOR:
- [C++诞生历史](https://blog.csdn.net/zxxssdsd/article/details/9309203).
- [C/C++ 误区二：void main()](https://blog.csdn.net/fengyuruhui/article/details/1682319).
## Birth

在Bjarne博士等人试图去分析UNIX的内核的时候(1979.04)，当时由于没有合适的工具能够有效的**分析由于内核分布而造成的网络流量**，以及怎样将内核模块化。

同年10月，Bjarne博士完成了一个可以运行的预处理程序，称之为Cpre，它为C加上了类似Simula的类机制。在这个过程中，Bjarne博士开始思考是不是要开发一种新的语言，当时贝尔实验室对这个想法很感兴趣，就让Bjarne博士等人组成一个开发小组，专门进行研究。

当时不是叫做C++，而是C with class，这是把它当作一种C语言的有效扩充。由于当时C语言在编程界居于老大的地位，要想发展一种新的语言，最强大的竞争对手就是C语言，所以当时有两个问题最受关注：

1. C++要在运行时间、代码紧凑性和数据紧凑性方面能够与C语言相媲美

2. 尽量避免在语言应用领域的限制。

在这种情况下，一个很自然的想法就是让C++从C语言继承过来，但是我们的**Bjarne为了避免受到C语言的局限性，参考了很多的语言，例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常**。下图是C++标准的上个世纪的历史：

作为Linux源码的C从B语言发展而来……



## Details

```c++
#include<cstdio>//头文件(.h) stdio代表standard input/output，也就是标准输入输出的意思(对键盘输入输出的支持)
#include<iostream>
using namespace std;
int main(void){// 圆括号（）表明main是一个函数，void表明main 函数不接受任何参数 int main(void)是ISO/ANSI C标准中定义的 main 函数定义方法之一
	cout<<"hello world!";
	return 0;
}// { 标志着函数体开始。函数体以闭大括弧 } 结束
```



**ISO/[ANSI C](https://baike.baidu.com/item/ANSI%20C/7657277)**

> ANSI C是由美国国家标准协会（ANSI）及国际标准化组织（ISO）推出的关于C语言的标准。ANSI C 主要标准化了现存的实现， 同时增加了一些来自 C++ 的内容 （主要是函数原型） 并支持多国字符集 （包括备受争议的三字符序列）。 ANSI C 标准同时规定了 C 运行期库例程的标准。

2. 头文件：包含着编译器进行编译时所需的信息。可能指明了函数名和函数调用方法，但是这些函数的**实现代码**在**预先编译**好了的**库文件**里。
3. **链接器**负责在库文件中寻找我们的程序所需的代码，并且把那些代码和我们写的程序进行链接，从而将我的写的程序**链接成可执行文件**。一句话，头文件用于指导编译器正确地将我们写的源程序编译成可执行文件。

**main函数**

误区：**void main()**

> C/C++ 中从来没有定义过**void main( )** 。**C++** 之父 **Bjarne Stroustrup** 在他的主页上的 **FAQ** 中明确地写着：
>
> The definition void main( ) { /* ... */ } is not and never has been C++, nor has it even been C.（ void main( ) 从来就不存在于 C++ 或者 C ）

在 **C89** 中，**main( )** 是可以接受的。**Brian W. Kernighan** 和 **Dennis M. Ritchie** 的经典巨著 The C programming Language 2e（《C 程序设计语言第二版》）用的就是 main( )。

**C98**中定义了如下两种 main 函数的定义方式：

```c++
int main( )//等同于上
int main( int argc, char *argv[] )
```

**C99** 标准中，只有以下两种定义方式是正确的：

```cpp
int main( void )//不需要从命令行中获取参数
int main( int argc, char *argv[] )//和上面的需求相反
```

 当然，``char *argv[]` 可以写成`char **argv`；

如果 main 函数的最后没有写 `return` 语句的话，

注意：

+ C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0; ，表示程序正常退出。
+ VC6(1998年)不会在目标文件中加入`return 0`；gcc3.2（Linux 下的 C 编译器）会在生成的目标文件中加入 return 0。

* main 函数的返回值应该定义为 int 类型，C 和 C++ 标准中都是这样规定的。虽然在一些编译器中，void main 可以通过编译（如 vc6），但并非所有编译器都支持 void main ，因为<font color="red">**标准中从来没有定义过** **void main** 。**g++3.2 中如果 main 函数的返回值不是 int** **类型，就根本通不过编译**</font>。而 gcc3.2 则会发出警告。所以，如果你想你的程序拥有很好的**可移植性**，请一定要用 int main 。(原来markdown的颜色设置可以用英文来代替，是可以说是很方便的)。

**返回值**

**main 函数的返回值**用于说明程序的退出状态。如果返回 0，则代表程序正常退出；返回非零(具体由系统决定)代表程序异常退出。

> [小实验] 在CMD里运行刚才编译好的exe，然后输入“echo **%ERRORLEVEL%**”，回车，就可以看到程序的返回值为 0 。
>
> 假设刚才编译好的文件是 a.exe ，如果输入“**a && dir**”，则会列出当前目录下的文件夹和文件。
>
> 但是如果改成“return -1”，或者别的非 0 值，重新编译后输入“a && dir”，则 dir 不会执行。
>
> 如果你闲，可以把 main 函数的返回值类型改成非 int 类型（如 float），重新编译后执行“a && dir”，看看会出现什么情况，想想为什么会出现那样的情况。顺便提一下，如果输入 **a || dir** 的话，则表示如果 a 异常退出，则执行 dir。

**表示了：**如果 && 前面的程序正常退出，则继续执行 && 后面的程序，否则不执行。也就是说，利**用程序的返回值，我们可以控制要不要执行下一个程序**。这就是 int main 的好处。

* 编译器也可以提供main()的更多重载版本，不过它们都必须返回int，这个int是返回给你的程序的调用者的，这是种“负责”的做法，“什么都不返回”可不大好哦。如果你程序的调用者不支持用“返回值”来交流，这个值会被自动忽略——但这也不能使void
    main()成为合法的C++或C代码。即使你的编译器支持这种定义，最好也不要养成这种习惯——否则你可能被其他C/C++程序员认为浅薄无知哦。
* 另外，还要请你注意：无论是ISO C++还是C99都不允许你省略返回类型。这也就是说，和C89及ARM C++[译注：指Margaret Ellis和Bjarne Stroustrup于1990年合著的《The Annotated C++ Reference Manual》中描述的C++]不同，int并不是缺省返回值类型。

**注释**: C99 之前的注释只是“*” ，C89之后加入//（**VC6** 支持 //，**TC2** 不支持）

**空间**: C95之前都是全局空间，C99后加入名空间

**申明的位置**: C99之后支持在任何地方进行申明 但是使用只能在声明之后。

**输出函数**: printf与cout: 

1. <font color="red">Printf **%d** 告诉 printf 用 num 的值替换掉 %d ，并且以
              **整数形式显示** num 的值(d 告诉 printf 以
              **十进制**整数的形式显示 num 的值)。</font>
2. cout能够识别类型的功能表明，其设计更灵活、更好用。由于`print()`不够精密，因此根本发现不了错误。它将继续处理，显示一堆乱码; cout可扩展的（extensible），也就是说，可以重新定义`< `运算符，使cout能够识别和显示所开发的新数据类型。

**`endl`和`\n`的区别**

1. 换行符是一种被称为“转义序列”的按键组合，`endl`是一个特殊的C++符号，诸如`endl`等对于`cout`来说有特殊含义的特殊符号被称为控制符（manipulator）。和`cout`一样，`endl`也是在头文件iostream中定义的，且位于名称空间`std`中。

2. `endl`确保程序继续运行前刷新输出（将其立即显示在屏幕上）；而使用`"\n"`不能提供这样的保证，这意味着在有些系统中，有时可能在您输入信息后才会出现提示。



**C++关键字**（一共32个）：

`auto`、`break`、`case`、`char `、`const`、`continue`、`default`、`do` 、`double`、`else`、`enum`、`extern` 、`float`、`for`、`goto`、`if `、`int`、`long`、`register`、`return` 、`short`、`signed`、`sizeof`、`static`、`struct`、`witch`、`typedef`、`union` 、`unsigned`、`void`、`volatile`、`while`.

当你作死想要用关键字作为变量名的时候也不是不可以，不要全局`using namespace std;`，你可以只是用`std::`达到相同的效果，然后用其他关键字做表，变量名……

**语句**(6种)：

> 声明语句：定义函数中使用的变量的名称和类型。
>
> 赋值语句：使用赋值运算符（=）给变量赋值。
>
> 消息语句：将消息发送给对象，激发某种行动。
>
> 函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
>
> 函数原型：声明函数的返回类型、函数接受的参数数量和类型。
>
> 返回语句：将一个值从被调用的函数那里返回到调用函数中。

`if( )~else` 条件语句、`for( )~` 循环语句、`while( )~` 循环语句、`do~while( )` 循环语句、`continue` 结束本次循环语句、`break` 中止执行`switch`或循环语句、`switch` 多分支选择语句、`goto` 转向语句、`return` 从函数返回语句。



## 强语言类型的优点

> 有些语言（最典型的是BASIC）在使用新名称时创建新的变量，而不用显式地进行声明。这看上去对用户比较友好，事实上从短期上说确实如此。问题是，如果错误地拼写了变量名，将在不知情的情况下创建一个新的变量。在BASIC中，ss程序员可能编写如下语句：
>
> ```basic
> CastleDark = 34
> CastleDank= CastleDark+MoreGhosts 
> PRINT CastleDark
> ```
>
> 由于CastleDank是拼写错误（将r拼成了n），因此所作的修改实际上并没有修改CastleDark。这种错误很难发现，因为它没有违反BASIC中的任何规则。然而，在C++中，将声明`CastleDark`，但不会声明被错误拼写的`CastleDank`，因此对应的C++代码将违反“使用变量前必须声明它”的规则，因此编译器将捕获这种错误，发现潜在的问题。



## 后缀名(区别c和c++)

| C/C++ |  头文件后缀名  |       源文件后缀名       |
| :---: | :------------: | :----------------------: |
|   c   |       .h       |            .c            |
|  C++  | .h, .hpp, .hxx | .cpp  .cc .cxx  .C  .c++ |

另外，不同编译器和不同的操作系统对不同的版本有所区别：

注意：

1. `.h`和`.hpp`的区别是：*.h里面只有声明，没有实现，而*`.hpp`里声明实现都有，后者可以减少`.cpp`的数量，适合用来编写公用的开源库。
2. `inl 文件`是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候内联函数较多或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体定义的代码添加到`INL文件`中，然后在该头文件的末尾将其用`#include`引入。由此也可以看到`inl文件`的例外一个用法的影子——模板函数、模板类的定义代码的存放。



## C? C++?

C++ 编写的程序，都能用等效的 C 程序代替，但 C++ 在语言层面上提供了 OOP/GP 语法、更严格的类型检查系统、大量额外的语言特性（如异常、RTTI等），并且 C++ 标准库也较丰富。有时候 C++ 的语法可使程序更简洁，如运算符重载、隐式转换。但另一方面，C 语言的 API 通常比 C++ 简洁，能较容易供其他语言程序调用。因此，一些 C++ 库会提供 C 的 API 封装，同时也可供 C 程序调用。相反，有时候也会把 C 的 API 封装成 C++ 形式，以支持 RAII 和其他 C++ 库整合等。



## gcc & g++ 

> GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言译器。GNU编译器套件包括C、C++、  Objective-C、 Fortran、Java、Ada和Go语言前端，也包括了这些语言的库（如libstdc++，libgcj等。） 

简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：

1. gcc与g++都可以编译c代码与c++代码。后缀为.cpp的，两者都会认为是C++程序；但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；。
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

```shell
gcc main.cpp -lstdc++
```

## Make/Compile

> 程序的生命周期是从一个高级C语言程序开始的（被人读懂）（高级编程语言）。为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后**这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来**。目标程序也称为可执行目标文件。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```shell
gcc-o hello hello.c
```

> 在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello，这个翻译过程可分为四个阶段<font color="red">（预处理器、编译器、汇编器和链接器）</font>，四个阶段的程序一起构成了**编译系统（compilation system）**。 ——摘自《深入理解计算机系统》

1. **预处理(Pre-processing)**：编译器将C源代码中的包含的头文件如stdio.h添加进来。

```shell
gcc -E hello.c -o hello.i #将hello.c预处理输出hello.i文件
```

2. **编译(Compiling)**：gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言

```shell
gcc –S hello.i –o hello.s  #将预处理输出文件hello.i汇编成hello.s文件
```

3. **汇编(Assembling)**：把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件

```shell
gcc –c hello.s –o hello.o #将汇编输出文件hello.s编译输出hello.o文件
```

4. **链接(Link)**：在成功编译之后，就进入了链接阶段

```shell
gcc hello.o –o hello #将编译输出文件hello.o链接成最终可执行文件hello
```


​    	运行该可执行文件，出现正确的结果如下

---

编译和链接的方式（Win）（其他平台后续再补）：

1. 下载一个在Windows命令提示符模式（在这种模式下，将于开一个类似王MS-DOS的窗口）下运行的免费命令行编译器。Cygwin和MinGW都包含编译器GNU C++，且可免费下载 它们使用的编译器名为gtt要使用g++编译器，首先需要打开一个命令提示符窗口。启动程序Cygwin和MinGw时，它们将自动为您打开一个命令提示符窗口。
    命令行编译器：`.c`用gcc，`.cpp`用g++，编译链接之后会生成一个按字母顺序的exe文件，例如`a.exe`文件。
    <font color="grey" size=2>这里说要提前下载一个编译器，但是我的电脑记得没有往环境变量里面添加这个，这个就有点迷???是Clion？？</font>
2. 通常，必须为程序创建一个项目，并将组成程序的一个或多个文件添加到该项目中。每个厂商提供的IDE（集成开发环境）都包含用于创建项目的菜单选项（可能还有自动帮助）。必须确定的非常重要的一点是，需要创建的是什么类型的程序。通常，编译器提供了很多选择，如Windows应用程序、MFC Windows应用程序、动态链接库、Activex控件、DOS或字符模式的可执行文件、静态库或控制台应用程序等。其中一些可能既有32位版本，又有64位版本.
    创建好项自后，需要对程序进行编译和链接。IDE通常提供了多个菜单项，如
    **Compile（编译）**对当前打开的文件中的代码进行编译。
    **Build（建立）、Make（生成）**：编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
    **Buld All（部建立）**重新编译所有的源代码文件。
    **Link（链接）**（如前所述）将编译后的源代码与所需的库代码组合起来。
    **Execute（执行）/Run（运行）**运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤。
    **Debug（调试）**以步进方式执行程序
    编译器可能让您选择要生成调试版还是发布版。调试版包含额外的代码，这会增大程序、降低执行速度，但可捷供详细的调试信息
